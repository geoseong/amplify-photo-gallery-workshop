[
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_prerequisites/1_account.html",
	"title": "AWS account 생성하기",
	"tags": [],
	"description": "",
	"content": "Workshop에서 사용하고자 하는 AWS 계정은 새로운 IAM 역할을 만들수 있어야 하고 다른 IAM 권한 범위를 지정할 수 있어야 합니다.\n 이미 AWS 계정을 가지고 있고, IAM 관리자 접속 권한이 있다면 이 페이지를 넘어가도 좋습니다.\n  관리자 접속 권한 계정이 없다면: 새로 하나 만듭시다.\n AWS 계정을 가지게 되었다면, 남은 워크샵 단계를 잘 따르고 있는 확인해보세요.\nAWS 계정에 대한 관리자 권한이 있는 IAM user : 워크샵에서 사용할 IAM user를 만듭니다.\n 사용자 상세정보를 입력합니다:  AdministratorAccess IAM 정책 연결:  create the new user 클릭:  login URL 저장:   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/",
	"title": "Amplify Web App Workshop",
	"tags": [],
	"description": "",
	"content": " AWS Amplify와 AWS AppSync로  사진 공유 웹 어플리케이션 구현 환영합니다! 이번 워크샵에서 React를 사용하여 사용자들이 사진을 업로드하고 공유하는 data-driven 기반의 안전한 사진 갤러리 웹 어플리케이션을 구현합니다. AWS AppSync를 이용하여 Amazon DynamoDB에 백업된 데이터를 GraphQL API를 통하여 빠르게 가져오고 실행합니다. AWS Amplify 라이브러리를 사용하여 사용자를 인증하고, API와 통신하며, 사진 업로드 관리를 어떻게 하는지 시연합니다. 마지막으로 Amazon Rekognition으로 AI 기반 오브젝트 태그를 추가하여 사용자가 수동으로 검색 데이터 입력하지 않아도 사진을 찾아주도록 구현합니다. "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/50_working_with_albums/5_managing_albums.html",
	"title": "앨범 관리",
	"tags": [],
	"description": "",
	"content": " 우리가 만든 웹어플리케이션은 사용자를 인증하는 기능과 안전하게 앨범 데이터를 만들고 조회하는 GraphQL API 엔드포인트가 있습니다. 이 두가지 기능을 연결해보겠습니다!\nAWS Amplify는 웹 또는 React Native 어플리케이션에 여러 클라우드 서비스를 쉽게 연동해주는 오픈소스 JavaScript라이브러리 입니다. 이제 Connect React 컴포넌트를 사용하여 리액트 컴포넌트가 렌더링 될 때 필요한 데이터를 자동으로 조회해 오도록 GraphQL API로 쿼리를 수행해봅시다.  Amplify CLI는 이미 src/aws-exports.js 에 포함된 모든 설정값을 읽어들였기 때문에 AppSync API와 통신하기 위한 설정 값을 알고 있습니다(Amplify JS 라이브러리에 전달할 설정값이 무엇인지 고민하지 않아도 됩니다). 우리는 API와 상호 작용할 새로운 코드를 추가하기만 하면 됩니다.\n 다음은 앨범 목록을 렌더링 할때의 모습입니다: 어플리케이션 업데이트 프런트엔드를 다음과 같이 업데이트 해 보겠습니다.\n 새로운 앨범 생성하기\n 앨범 목록보기\n 앨범을 클릭하면 앨범 세부정보 확인하기\n  사진 앨범 디렉토리에서 다음 명령어를 수행하여 라우팅을 위한 라이브러리를 설치합니다. npm install --save react-router-dom\n일반적으로 컴포넌트 및 요소 별로 각각의 별도 파일을 만들지만 이번 워크샵에서는 App.js 파일 안에서 모든 코드를 작성하겠습니다.\n photo-albums/src/App.js를 다음과 같이 바꾸십시오:\n// src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;;  import Amplify, { API, graphqlOperation } from \u0026#39;aws-amplify\u0026#39;; import { Connect, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!) { getAlbum(id: $id) { id name } } `; class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { render() { return ( \u0026lt;Connect query={graphqlOperation(GetAlbum, { id: this.props.id })}\u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.getAlbum) return; return \u0026lt;AlbumDetails album={data.getAlbum} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class AlbumDetails extends Component { render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;p\u0026gt;TODO: Allow photo uploads\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;TODO: Show photos for this album\u0026lt;/p\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } }  export default withAuthenticator(App, {includeGreetings: true}); src/App.js에서 변경된 내용  aws-amplify-react에서 Connect 컴포넌트 추가\n semantic-ui-react에서 UI 컴포넌트 추가\n aws-amplify에서 API 및 graphqlOperation 추가\n react-router-dom에서 라우팅 컴포넌트 추가\n makeComparator를 추가하여 JS에서 문자 정렬 기능 추가\n NewAlbum, AlbumsList, AlbumsDetailsLoader, AlbumDetails, AlbumsListLoader 컴포넌트 추가\n ListAlbums, SubscribeToNewAlbums, GetAlbum GraphQL 쿼리 및 변이(mutations) 추가\n 현재 URL 경로를 기반으로 다양한 컴포넌트를 제공하도록 App 컴포넌트를 업데이트 (라우팅 적용)\n  어플리케이션을 실행해보세요. 어플리케이션을 다시 실행하여 새로운 기능을 확인합니다.\n 앨범 목록을 확인합니다.\n 새 앨범을 만들고 앨범 목록에 새로 추가한 앨범이 조회되는지 확인합니다.\n 앨범 세부정보를 확인합니다.\n 앨범을 볼 때 \u0026lsquo;앨범 목록으로 돌아 가기\u0026rsquo;를 클릭하면 앨범 목록리스트로 돌아갑니다.\n  AWS Amplify의 Connect 컴포넌트(https://aws-amplify.github.io/docs/js/api#connect) (aws-amplify-react 패키지로부터 임포트)를 통해 앨범 데이터가 로딩됩니다.\n우리는 이 컴포넌트를 query prop에 GraphQL 쿼리 연산을 담아 전달하기만 하면 됩니다. 컴포넌트가 마운트 될 때 해당 쿼리가 실행되고 자식 함수에게 데이터, 로딩, 에러를 인자(arguments)로 전달합니다. 전달된 인자들을 이용하여 로딩 텍스트를 보여주거나, 성공적으로 페치된 데이터를 AlbumsList 컴포넌트에게 전달함으로 적절히 렌더링 작업을 수행합니다.\n 위에서 사용한 listAlbums 쿼리는 매우 높은 제한 인자를 전달합니다.(listAlbums(limit: 9999)) 한번의 요청으로 모든 앨범 정보를 가져와서 클라이언트 사이드에서 사전순서로 정렬합니다. (페이징 처리된 DynamoDB 응답을 활용하지 않습니다.) 이 방법은 AlbumsList 코드를 매우 간단하게 유지하므로 성능이나 네트워크 비용 측면에서 활용할 가치가 있습니다.\n 새로운 앨범이 만들어 질 때마다 AppSync 실시간 구독을 활용하여 앨범 목록이 자동으로 갱신되는 것도 주목해주세요.   GraphQL 스키마에는 Subscription 타입이 포함되어 있습니다. AWS AppSync에서 AWS 리소스를 만들 때 (DynamoDB 테이블 및 AWS AppSync 리졸버와 같은) 여러 구독 요소들이 자동으로 함께 생성됩니다. onCreateAlbum Subscription이 그 중 하나에 해당합니다.   Connect 컴포넌트의 subscription 속성을 통해 onCreateAlbum 의 이벤트 데이터를 구독하고 onSubscriptionMsg 속성을 통해 onCreateAlbum 이벤트가 발생하면 AlbumsList 의 데이터를 업데이트하도록 지시합니다.   Subscription 속성 내용은 query 속성으로 제공한 것들과 매우 유사해 보입니다. 우리가 수신할 Subscription이 무엇인지 지정하고, 새로운 데이터로 채워야할 필드가 무엇인지 포함된 쿼리일 뿐입니다. 약간 까다로운 점은 subscription으로 부터 받아온 새 데이터를 처리할 핸들러 함수를 정의 해야한다는 것인데 이 핸들러 함수는 Connect 컴포넌트가 ListAlbums 컴포넌트를 갱신하는데 필요한 새로운 데이터를 반환하도록 구현해야합니다. 위 코드에 구현되어 있습니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/10_rekognition.html",
	"title": "Amazon Rekognition 연동하기",
	"tags": [],
	"description": "",
	"content": " 직접 태깅하지 않은 이미지도 검색할 수 있으면 좋겠습니다. 다행이 Amazon Rekognition 덕분에 이 기능을 추가하기는 매우 쉽습니다. 사진을 주면 해당 이미지에 적절한 레이블로 응답하는 DetectLabels API를 사용할 수 있습니다. 완벽합니다!\nAmazon Rekognition의 DetectLabels 간략 정리  입력한 이미지를 base64 인코딩한 이미지 바이트열이나 Amazon S3 버킷에 이미지 참조로 전달합니다. AWS CLI로 Amazon Rekognition 작업을 호출하는 경우 이미지 바이트열을 전달하는 기능은 지원하지 않습니다. 이미지는 PNG 또는 JPEG 형식의 파일이어야 합니다.  API는 각 개체와 장면과 컨셉에 따라 하나 이상의 레이블을 반환합니다. 각 레이블은 이미지에 포함된 개체의 이름과 신뢰도 수준 정보를 제공합니다. 예를 들어 입력 이미지에 등대, 바다, 바위가 있다고 가정해봅니다. 그 응답에는 각 개체당 1개씩 3개의 모든 레이블을 포함합니다.  {Name: lighthouse, Confidence: 98.4629}  {Name: rock,Confidence: 79.2097}  {Name: sea,Confidence: 75.061}\n Rekognition과 사진 처리 람다 연동하기 photo_processor 람다 함수에 Amazon Rekognition을 연동하겠습니다.\namplify/backend/function/workshopphotoprocessor/src/index.js를 다음 버전으로 변경합니다.\n// photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js  const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3({ signatureVersion: \u0026#39;v4\u0026#39; }); const Rekognition = new AWS.Rekognition(); const DynamoDBDocClient = new AWS.DynamoDB.DocumentClient({apiVersion: \u0026#39;2012-08-10\u0026#39;}); const uuidv4 = require(\u0026#39;uuid/v4\u0026#39;); /* Note: Sharp requires native extensions to be installed in a way that is compatible with Amazon Linux (in order to run successfully in a Lambda execution environment). If you\u0026#39;re not working in Cloud9, you can follow the instructions on http://sharp.pixelplumbing.com/en/stable/install/#aws-lambda how to install the module and native dependencies. */ const Sharp = require(\u0026#39;sharp\u0026#39;); // We\u0026#39;ll expect these environment variables to be defined when the Lambda function is deployed const THUMBNAIL_WIDTH = parseInt(process.env.THUMBNAIL_WIDTH, 10); const THUMBNAIL_HEIGHT = parseInt(process.env.THUMBNAIL_HEIGHT, 10); const DYNAMODB_PHOTOS_TABLE_NAME = process.env.DYNAMODB_PHOTOS_TABLE_ARN.split(\u0026#39;/\u0026#39;)[1]; async function getLabelNames(bucketName, key) { let params = { Image: { S3Object: { Bucket: bucketName, Name: key } }, MaxLabels: 50, MinConfidence: 70 }; const detectionResult = await Rekognition.detectLabels(params).promise(); const labelNames = detectionResult.Labels.map((l) =\u0026gt; l.Name.toLowerCase()); return labelNames; }  function storePhotoInfo(item) { const params = { Item: item, TableName: DYNAMODB_PHOTOS_TABLE_NAME }; return DynamoDBDocClient.put(params).promise(); } async function getMetadata(bucketName, key) { const headResult = await S3.headObject({Bucket: bucketName, Key: key }).promise(); return headResult.Metadata; } function thumbnailKey(filename) { return `public/resized/${filename}`; } function fullsizeKey(filename) { return `public/${filename}`; } function makeThumbnail(photo) { return Sharp(photo).resize(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT).toBuffer(); } async function resize(bucketName, key) { const originalPhoto = (await S3.getObject({ Bucket: bucketName, Key: key }).promise()).Body; const originalPhotoName = key.replace(\u0026#39;uploads/\u0026#39;, \u0026#39;\u0026#39;); const originalPhotoDimensions = await Sharp(originalPhoto).metadata(); const thumbnail = await makeThumbnail(originalPhoto); await Promise.all([ S3.putObject({ Body: thumbnail, Bucket: bucketName, Key: thumbnailKey(originalPhotoName), }).promise(), S3.copyObject({ Bucket: bucketName, CopySource: bucketName + \u0026#39;/\u0026#39; + key, Key: fullsizeKey(originalPhotoName), }).promise(), ]); await S3.deleteObject({ Bucket: bucketName, Key: key }).promise(); return { photoId: originalPhotoName, thumbnail: { key: thumbnailKey(originalPhotoName), width: THUMBNAIL_WIDTH, height: THUMBNAIL_HEIGHT }, fullsize: { key: fullsizeKey(originalPhotoName), width: originalPhotoDimensions.width, height: originalPhotoDimensions.height } }; }; async function processRecord(record) { const bucketName = record.s3.bucket.name; const key = record.s3.object.key; if (key.indexOf(\u0026#39;uploads\u0026#39;) != 0) return; const metadata = await getMetadata(bucketName, key); const sizes = await resize(bucketName, key); const labelNames = await getLabelNames(bucketName, sizes.fullsize.key);  const id = uuidv4(); const item = { id: id, owner: metadata.owner, labels: labelNames,  photoAlbumId: metadata.albumid, bucket: bucketName, thumbnail: sizes.thumbnail, fullsize: sizes.fullsize, createdAt: new Date().getTime() } await storePhotoInfo(item); } exports.handler = async (event, context, callback) =\u0026gt; { try { event.Records.forEach(processRecord); callback(null, { status: \u0026#39;Photo Processed\u0026#39; }); } catch (err) { console.error(err); callback(err); } };  바뀐 것들  Amazon Rekognition API를 이용하기 위해 AWS.Recognition 인스턴스를 생성했습니다.\n Rekognition.detectLabels 을 이용하여 주어진 S3의 사진을 위한 적절한 레이블의 목록을 돌려주는 getLabelNames 함수가 추가되었습니다.\n getLabelNames 함수를 이용하여 사진 레이블을 가지고 와서, DynamoDB에 해당 기록과 함께 저장되도록 processRecord 함수를 수정했습니다.\n  사진 처리기 코드는 이제 Amazon Rekognition의 detectLables API를 사용합니다. 그러나 이전 장에서 이 작업에 대한 권한을 이미 추가했기때문에 CloudFormation 템플릿을 다시 갱신할 필요는 없습니다.\n사진 처리 람다를 재배포하기 photo-albums 디렉토리에서 amplify push를 실행해서 갱신된 버전의 사진 처리 함수를 배포합니다.\n배포가 끝나면 새 사진을 앨범에 추가해 봅니다. 그리고 DynamoDB의 PhotoTable에 해당 행을 찾아보아서 새로 업로드한 것에 적절히 레이블이 주어졌는지 확인해 봅니다. 해당 사진과 관련있는 레이블이 포함되었길 바랍니다!\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql/10_setting_up_appsync.html",
	"title": "AppSync 세팅",
	"tags": [],
	"description": "",
	"content": " 이제 인증된 사용자를 가지고 앨범을 만들기 위한 API를 만들어 봅시다. 이 앨범에는 아직 사진이 없고 단순히 이름과 앨범을 생성한 사용자 이름만 있을 것입니다.\nAWS AppSync를 사용하여 API를 구현하고, 데이터 기반 어플리케이션을 구현하기 위하여 관리형 GraphQL 서비스를 사용합니다. 아직 GraphQL이 익숙하지 않다면 워크샵 단계를 진행하기 전에 시간을 내어 다음 자료를 살펴 보세요. https://graphql.github.io/learn/ 단계를 계속하는 동안에도 질문이 생긴다면 위 자료를 참조하시기 바랍니다.\n AWS AppSync API 추가하기 photo-albums 디렉토리에서 다음 명령어를 수행하세요 amplify add api\n수행결과는 다음과 같습니다.\n$ amplify add api ? Please select from one of the below mentioned services GraphQL ? Provide API name: photoalbums ? Choose an authorization type for the API Amazon Cognito User Pool ? Do you have an annotated GraphQL schema? No ? Do you want a guided schema creation? Yes ? What best describes your project: One-to-many relationship (e.g., “Blogs” with “Posts” and “Comments”) ? Do you want to edit the schema now? Yes Please manually edit the file created at /home/ec2-user/environment/photo-albums/amplify/backend/api/photoalbums/schema.graphql ? Press enter to continue (아직 Enter키를 누르지 마세요!) GraphQL Schema 정의 앨범과 사진을 저장하고 조회하기 위한 스키마 정의입니다.\n 다음 경로의 파일에 photo-albums/amplify/backend/api/photoalbums/schema.graphql 아래 내용을 복사하여 붙여넣습니다. 예제 스키마 컨텐츠를 대체합니다. 파일을 저장하는 것을 잊지 마세요.\n참고 : Cloud9에서 터미널의 파일 이름에 마우스를 올려 놓고 클릭 한 다음 \u0026lsquo;열기\u0026rsquo;를 선택할 수 있습니다.\n# amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [{allow: owner}]) { id: ID! name: String! photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) { id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! } type PhotoS3Info { key: String! width: Int! height: Int! } 명령 프롬프트로 돌아가서 Enter 를 한번만 눌러 계속 진행합니다.\n amplify push 명령어를 수행하세요 그리고 업데이트를 계속 진행할 것인지 확인합니다.\n 코드 생성에 대한 메세지가 표시되면, \u0026lsquo;No\u0026rsquo;를 선택합니다.\n Amplify가 새로운 리소스를 프로비저닝하는 동안 몇 분 정도 기다립니다.\n  이제 Code 작성 없이 앨범과 사진 데이터에 대하여 CRUDL 작업을 수행할 수 있는 GraphQL API가 생겼습니다!  AWS AppSync가 필드를 데이터로 변환하는 방식이 숨겨져 있는것은 아니니 걱정하지 마세요. 자동으로 생성된 각 resolver들은 우리가 보기에 적절하도록 수정 할 수 있습니다. (다음 단계에서 확인 할수 있습니다) 지금은 앨범을 몇개 추가하고, 그것들을 리스트로 조회해 보겠습니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_prerequisites/10_workspace.html",
	"title": "Cloud9 Workspace 생성하기",
	"tags": [],
	"description": "",
	"content": " AWS Cloud9은 cloud-based의 통합 개발 환경(IDE)입니다. 브라우저에서 바로 코드를 작성하고 실행시키고, 디버깅할수 있습니다. Cloud9은 코드 편집기, 디버거와 터미널을 제공합니다. 또한 Javascript, Python, PHP 등의 인기 있는 프로그래밍언어를 위한 필수적인 도구들이 미리 패키징 되어 제공됩니다. 무엇보다도 새로운 프로젝트 시작을 위해 설치 파일이 필요하거나, 개발 환경 설정이 필요하지 않습니다.\nThe Cloud9의 작업영역은 AWS root 계정이 아닌, Administrator 권한을 가진 IAM user에 의해서 작성 되어야 합니다. root 계정이 아닌 IAM User로 로그인 하여 작업 중인게 맞는지 꼭 확인하세요.\n 광고 차단기, Javascript 비활성화 도구 및 차단 추적기 등은 Cloud9 에서는 비활성화 하세요. 작업 영역에 영향을 줄 수 있습니다.\n 새 환경 만들기  이 실습은 버지니아 리전(us-east-1)에서 실행됩니다. Cloud9 web console 로 이동 Create environment 선택 workshop으로 이름을 붙이고 Next step으로 넘어가세요. Create a new instance for environment (EC2) 선택하고 t2.small을 고르세요 모든 환경 설정을 있는 그대로 두고 Next step로 이동합니다. Create environment를 클릭합니다.  Layout 정리 작업 환경이 나타나면, 레이아웃을 본인에게 맞게 커스터마이징 합니다. 1) welcome tab을 닫고 2) 아래 작업 영역도 닫습니다. 3)새로운 terminal 탭을 메인 작업 영역에 띄웁니다. : 당신의 작업 영역은 이제 이렇게 보일거에요.: Cloud9 workspace 메뉴에서 View / Themes / Solarized / Solarized Dark 테마를 직접 선택할 수 있습니다.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus/10_lightbox_photos.html",
	"title": "LIGHTBOX 만들어 전체 크기의 사진들 보기",
	"tags": [],
	"description": "",
	"content": " 아직 우리는 유저가 어플리케이션에서 썸네일을 클릭하여 더 큰 사진을 볼 수 있도록 하는 기능을 다루지 않았습니다. 이미 우리는 API로부터 전체 크기와 썸네일 크기의 데이터를 모두 가지고 올 수 있기 때문에, 프런트엔드 어플리케이션에 몇줄 정도 코드를 추가하는 것 만으로도 이 기능을 제공할 수 있습니다.\n프런트엔드 수정하기 아래의 수정된 버전으로 photo-albums/src/App.js를 대체 해 주세요: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Container, Divider, Form, Grid, Header, Input, List, Modal, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage, Auth } from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } fullsize { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } } class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const user = await Auth.currentAuthenticatedUser(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId, owner: user.username } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { constructor(props) { super(props); this.state = { selectedPhoto: null }; } handlePhotoClick = (photo) =\u0026gt; { this.setState({ selectedPhoto: photo }); } handleLightboxClose = () =\u0026gt; { this.setState({ selectedPhoto: null }); }  photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} onClick={this.handlePhotoClick.bind(this, photo.fullsize)}  /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;Lightbox photo={this.state.selectedPhoto} onClose={this.handleLightboxClose} /\u0026gt;  \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class Lightbox extends Component { render() { return ( \u0026lt;Modal open={this.props.photo !== null} onClose={this.props.onClose} \u0026gt; \u0026lt;Modal.Content\u0026gt; \u0026lt;Container textAlign=\u0026#39;center\u0026#39;\u0026gt; { this.props.photo? \u0026lt;S3Image imgKey={this.props.photo.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} theme={{ photoImg: { maxWidth: \u0026#39;100%\u0026#39; } }} onClick={this.props.onClose} /\u0026gt; : null } \u0026lt;/Container\u0026gt; \u0026lt;/Modal.Content\u0026gt; \u0026lt;/Modal\u0026gt; ); } }  class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nsrc/App.js 에서 무엇이 수정되었나요  semantic-ui-react로부터 Container 와 Modal 컴포넌트들을 불러왔습니다.\n GetAlbum GraphQL의 쿼리에 필드를 추가함으로서 전체 크기의 사진 정보를 가져올 수 있습니다.\n 현재 선택된 사진을 알기 위해서 PhotosList 컴포넌트를 수정하여 중첩된 Lightbox 컴포넌트로 전달하였습니다.\n 선택된 사진의 전체 크기 사진을 모달 화면에서 렌더링 하기 위해서 Lightbox 컴포넌트를 생성하였습니다.\n  어플리케이션을 작동시켜 보세요 어플리케이션을 한 번 더 확인한 후 썸네일을 클릭해 보세요. 이제 전체 크기 사진이 팝업되는 것을 볼 수 있을 것입니다. 전체 크기 사진을 클릭함으로서 썸네일 사진의 뷰로 돌아갈 수 있습니다.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started/10_what_we_will_build.html",
	"title": "무엇을 빌드하나",
	"tags": [],
	"description": "",
	"content": " 목표 이 워크샵에서 다음을 포함한 몇 가지 기능이 있는 어플리케이션을 빌드합니다.\n 사용자 등록 및 인증을 하게하여 누가 어떤 사진 앨범의 소유자인지 알 수 있습니다.\n API 서버를 구현해서 사용자가 소유한 앨범과 사진들을 로딩하여 보여줄 수 있습니다.\n 누가 무엇을 볼 수 있는가에 대한 권한 정보, 앨범 정보, 사진 정보를 저장하기 때문에 API는 데이터를 빠르게 조회하고 저장하는 신뢰성있는 저장소를 갖습니다.\n 사용자가 앨범에 업로드하는 모든 사진을 저장하는 공간이 생깁니다. (S3)\n 자동으로 사진 썸네일(미리보기)을 생성하므로 사용자가 앨범 목록을 조회했을때, 전체 해상도의 사진까지 목록으로 전달할 필요가 없습니다.\n 업로드한 사진과 관련한 레이블을 자동으로 감지하고 레이블을 기반으로 사진 검색이 가능합니다.\n  구성도 다음은 앞으로 사용할 서비스와 각각이 어떻게 연결되었는지 표시한 구성도입니다.\n사용 도구 위에 언급한 각각의 문제를 처리할 수 있는 확장 가능하고 고가용성의 시스템을 우리 힘으로 다 만들고자 한다면, 아마 어플리케이션을 제대로 구현하는것은 힘들것 같습니다. 다행히 AWS는 현대적이고 견고한 애플리케이션을 만드는데 필요한 많은 서비스와 도구를 제공합니다. 우리는 다음의 다양한 도구와 서비스를 사용할 것입니다.\n AWS Amplify CLI는 클라우드 서비스를 빠르게 프로비저닝하고 구성합니다.\n AWS Amplify JavaScript 라이브러리는 프론트와 클라우드리소스를 연결합니다.\n Amazon Cognito는 사용자 등록과 인증을 처리합니다.\n Amazon Simple Storage Service (S3)는 사용자가 업로드한 많은 사진을 저장하고 제공하며 어플리케이션의 정적 에셋을 호스팅합니다.\n Amazon DynamoDB는 사진과 앨범 데이터에 대한 API 쿼리를 수밀리초 응답으로 제공합니다.\n AWS AppSync는 프론트엔드에 GraphQL API를 호스팅합니다.\n AWS Lambda는 클라우드에서 사진의 썸네일을 비동기적으로 생성합니다.\n Amazon Rekognition는 업로드한 사진의 연관된 레이블을 감지합니다.\n Amazon Elasticsearch Service는 사진의 레이블을 검색하고 색인을 생성합니다.\n  이 서비스의 일부 혹은 전부가 다 새로울 지라도 걱정하지 마십시오. 위에 언급한 모든 것을 사용해서 시작할 때에 알아야 할 모든 것을 다룰 것입니다. 무엇보다 빌드보다 더 좋은 배움의 방법은 없으니 시작합시다!\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth/10_adding_auth_back.html",
	"title": "백엔드 구성하기",
	"tags": [],
	"description": "",
	"content": " 이제 우리에게 간단한 리액트 어플리케이션이 있으니, 어플리케이션으로 사용자 등록하고 로그인하도록 만들겠습니다. 지금 아무 것도 할 수 없지만 백엔드 API에 조회하는 기능을 추가하면 어떤 사용자가 우리 시스템을 사용하는지 알 수 있습니다.\nAWS Amplify CLI는 리엑트와 리엑트 네이티브용 iOS와 안드로이드에 SDK를 제공하여 웹과 모바일 어플리케이션에 클라우드 기능을 손쉽게 추가할 수 있습니다. 시작을 위해 새 애플리케이션을 만들고 사용자 인증을 가능토록 합니다. 어플리케이션에 AWS Amplify CLI로 구성하여 어플리케이션과 오픈소스 AWS Amplify 라이브러리를 연결합니다. 이제 해야 할 것은 리액트 어플리케이션에서 이것을 사용하면 됩니다. AWS Amplify는 클라우드 서비스에서 동작하는 괜찮은 추상화와 어플리케이션에서 사용할 유용한 리액트 컴포넌트를 포함합니다.\n 로그인 화면은 다음과 같습니다. Amplify 초기화 커맨드라인으로 photo-albums 디렉터리에서 :\n photo-albums 디렉터리로 들어갑니다. cd photo-albums\n amplify init를 실행합니다.\n \u0026lsquo;photo-albums\u0026rsquo;을 기본 프로젝트명으로 하기 위해 Enter를 누르십시요.\n environment name은 \u0026lsquo;master\u0026rsquo;를 입력합니다.\n Cloud9을 사용중이시면 default editor에 \u0026lsquo;None\u0026rsquo; 선택하십시요. (만약 Cloud9이 아닌 다른 에디터를 사용한다면 해당 에디터를 선택해 주세요)\n 프롬프트가 나오면 JavaScript와 react를 선택하십시요.\n 경로와 명령어에는 기본값을 선택합니다.\n 프롬프트가 나오면 default 프로파일을 선택하십시요.\n  이렇게 하면 Amazon Cognito 유저 풀을 구성하여 사용자가 가입하고 로그인을 위한 백엔드 역할을 할 수 있는 새 로컬 구성을 생성합니다(Amazon Cognito와 유저 풀에 대한 자세한 내용은 아래에 있습니다). 이 단계를 더 자세히 보시려면 AWS Amplify 인증 가이드에서 \u0026lsquo;Installation and Configuration\u0026rsquo; 항목을 살펴보십시요.\n 인증 추가하기  인증을 추가하기 위해 amplify add auth를 실행합니다.\n 기본 인증 및 보안 구성을 사용할지 질문에는 Yes를 선택합니다.\n 로그인시 유저 인증은 Username을 선택합니다.\n 가입시에 입력항목은 Email을 선택합니다.\n 클라우드에 변경 사항을 반영하기 위해 amplify push를 실행합니다.\n 프로비저닝이 완료될 때까지 기다립니다. 몇 분이 소요됩니다.\n  Amplify CLI는 적절한 클라우드 리소스로 프로비저닝하고 src/aws-exports.js 파일을 어플리케이션에서 사용하는 클라우드 리소스의 모든 구성 데이터로 갱신합니다.\n 축하합니다! 바로 방금 귀하는 Amazon Cognito로 수백만 사용자까지 확장할 수 있는 사용자 등록과 권한 부여를 위한 서버리스 백엔드를 만들었습니다.\nAmazon Cognito를 사용하면 웹과 모바일 애플리케이션에 사용자 등록, 로그인, 접근제어 기능을 쉽고 빠르게 추가할 수 있습니다. 방금 생성한 유저 풀은 보안된 사용자 디렉터리로 이를 이용하여 사용자가 생성한 사용자명과 암호로 로그인할 수 있습니다. Amazon Cognito(Amplify CLI 함께)는 또한 Facebook, Google, Amazon 같은 소셜 인증 공급자와 SAML 2.0을 통한 엔터프라이즈 인증 공급자를 이용한 로그인 구성도 지원합니다. 자세한 내용을 알기 원하시면 Amazon Cognito Developer Resources page와 AWS Amplify Authentication documentation를 살펴보십시요.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_prerequisites.html",
	"title": "사전준비",
	"tags": [],
	"description": "",
	"content": " Workshop 사전 준비  AWS account 생성하기   Cloud9 Workspace 생성하기   설치 \u0026amp; 설정   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails/10_creating_a_photo_processor_lambda.html",
	"title": "사진을 처리하는 람다 함수 만들기",
	"tags": [],
	"description": "",
	"content": " 사진 처리 람다 함수를 만들어서 사진을 리사이즈 할 수 있게 합니다.\n아래 지시를 따를 때에 람다 함수명을 반드시 workshopphotoprocessor 으로 합니다.   이후에 몇가지 클라우드 포메이션 템플릿을 수정하고, 이름이 workshopphotoprocessor인 함수는 이번 워크샵을 위해 하드 코딩합니다(꼭 수정할 부분을 줄이기 위해)\n  photo-albums 디렉토리에서 amplify function add를 실행해서 아래 보여진 것과 비슷한 방식으로 프롬프트에 답합니다. 두번째 단계를 계속하기 전에 엔터를 꼭 눌러야 합니다.\n$ amplify function add Using service: Lambda, provided by: awscloudformation ? Provide a friendly name for your resource to be used as a label for this category in the project: workshopphotoprocessor ? Provide the AWS Lambda function name: workshopphotoprocessor ? Choose the function template that you want to use: Hello world function ? Do you want to edit the local lambda function now? Yes Please manually edit the file created at /home/ec2-user/environment/photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js ? Press enter to continue \u0026lt;Enter\u0026gt; Successfully added resource workshopphotoprocessor locally. photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js 파일을 다음 내용으로 변경합니다. // amplify/backend/function/workshopphotoprocessor/src/index.js  const AWS = require(\u0026#39;aws-sdk\u0026#39;); const S3 = new AWS.S3({ signatureVersion: \u0026#39;v4\u0026#39; }); const DynamoDBDocClient = new AWS.DynamoDB.DocumentClient({apiVersion: \u0026#39;2012-08-10\u0026#39;}); const uuidv4 = require(\u0026#39;uuid/v4\u0026#39;); /* Note: Sharp requires native extensions to be installed in a way that is compatible with Amazon Linux (in order to run successfully in a Lambda execution environment). If you\u0026#39;re not working in Cloud9, you can follow the instructions on http://sharp.pixelplumbing.com/en/stable/install/#aws-lambda how to install the module and native dependencies. */ const Sharp = require(\u0026#39;sharp\u0026#39;); // We\u0026#39;ll expect these environment variables to be defined when the Lambda function is deployed const THUMBNAIL_WIDTH = parseInt(process.env.THUMBNAIL_WIDTH, 10); const THUMBNAIL_HEIGHT = parseInt(process.env.THUMBNAIL_HEIGHT, 10); const DYNAMODB_PHOTOS_TABLE_NAME = process.env.DYNAMODB_PHOTOS_TABLE_ARN.split(\u0026#39;/\u0026#39;)[1]; function storePhotoInfo(item) { const params = { Item: item, TableName: DYNAMODB_PHOTOS_TABLE_NAME }; return DynamoDBDocClient.put(params).promise(); } async function getMetadata(bucketName, key) { const headResult = await S3.headObject({Bucket: bucketName, Key: key }).promise(); return headResult.Metadata; } function thumbnailKey(filename) { return `public/resized/${filename}`; } function fullsizeKey(filename) { return `public/${filename}`; } function makeThumbnail(photo) { return Sharp(photo).resize(THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT).toBuffer(); } async function resize(bucketName, key) { const originalPhoto = (await S3.getObject({ Bucket: bucketName, Key: key }).promise()).Body; const originalPhotoName = key.replace(\u0026#39;uploads/\u0026#39;, \u0026#39;\u0026#39;); const originalPhotoDimensions = await Sharp(originalPhoto).metadata(); const thumbnail = await makeThumbnail(originalPhoto); await Promise.all([ S3.putObject({ Body: thumbnail, Bucket: bucketName, Key: thumbnailKey(originalPhotoName), }).promise(), S3.copyObject({ Bucket: bucketName, CopySource: bucketName + \u0026#39;/\u0026#39; + key, Key: fullsizeKey(originalPhotoName), }).promise(), ]); await S3.deleteObject({ Bucket: bucketName, Key: key }).promise(); return { photoId: originalPhotoName, thumbnail: { key: thumbnailKey(originalPhotoName), width: THUMBNAIL_WIDTH, height: THUMBNAIL_HEIGHT }, fullsize: { key: fullsizeKey(originalPhotoName), width: originalPhotoDimensions.width, height: originalPhotoDimensions.height } }; }; async function processRecord(record) { const bucketName = record.s3.bucket.name; const key = record.s3.object.key; if (key.indexOf(\u0026#39;uploads\u0026#39;) != 0) return; const metadata = await getMetadata(bucketName, key); const sizes = await resize(bucketName, key); const id = uuidv4(); const item = { id: id, owner: metadata.owner, photoAlbumId: metadata.albumid, bucket: bucketName, thumbnail: sizes.thumbnail, fullsize: sizes.fullsize, createdAt: new Date().getTime() } await storePhotoInfo(item); } exports.handler = async (event, context, callback) =\u0026gt; { try { event.Records.forEach(processRecord); callback(null, { status: \u0026#39;Photo Processed\u0026#39; }); } catch (err) { console.error(err); callback(err); } };  \n photo-albums/amplify/backend/function/workshopphotoprocessor/src/package.json 파일 내용을 다음으로 바꿉니다.\n{ \u0026#34;name\u0026#34;: \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The photo uploads processor\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;sharp\u0026#34;: \u0026#34;^0.20.2\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;^3.3.2\u0026#34; } } photo-albums 디렉토리에서 amplify function build를 실행하고 엔터를 눌러 확인합니다. 람다 함수의 package.json에 종속 패키지를 설치합니다. VScode 로 작성하고 계시다면..\n아래 amplify function build 를 수행한 후 다음과 같이 작업해주세요\nAWS Lambda 실행환경에 맞는 sharp 라이브러리가 빌드 되어야 합니다.\n1. 위에서 생성한 package.json 파일이 있는 photo-albums/amplify/backend/function/workshopphotoprocessor/src 경로로 이동 합니다.\n2. 다음 명령어를 수행합니다.\nrm -rf node_modules/sharp\nnpm install --arch=x64 --platform=linux --target=8.10.0 sharp\n  photo-albums/amplify/backend/function/workshopphotoprocessor/parameters.json 파일을 생성하고 다음 내용을 넣습니다.\n{ \u0026#34;S3UserfilesBucketName\u0026#34;: \u0026#34;REPLACE_WITH_USERFILES_BUCKET_NAME\u0026#34;, \u0026#34;DynamoDBPhotosTableArn\u0026#34;: \u0026#34;REPLACE_WITH_DYNAMO_PHOTOS_TABLE_ARN\u0026#34; } 생성한 parameters.json 파일에서 REPLACE_WITH_USERFILES_BUCKET_NAME 부분은 Amplify가 생성한 S3 유저 파일 버킷 이름으로 바꿉니다.\n이 값은 photo-albums/src/aws-exports.js 파일에서 aws_user_files_s3_bucket 항목의 키 값으로 찾을 수 있습니다.\n parameters.json 파일에서 REPLACE_WITH_DYNAMO_PHOTOS_TABLE_ARN 부분은 AppSync에서 사진 데이터 관리를 위해 사용하는 DynamoDB 테이블의 ARN으로 바꿉니다.\n이 ARN값은 AppSync API 콘솔의 Data Sources 섹션에서, PhotoTable 항목을 찾고 Resource 컬럼의 링크를 클릭하면 연관된 DynamoDB 테이블로 이동하고, Overview 탭의 최하단에서 찾을 수 있습니다.\n photo-albums/amplify/backend/function/workshopphotoprocessor/workshopphotoprocessor-cloudformation-template.json 를 다음 내용으로 변경합니다. { \u0026#34;AWSTemplateFormatVersion\u0026#34;: \u0026#34;2010-09-09\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Lambda resource stack creation using Amplify CLI\u0026#34;, \u0026#34;Parameters\u0026#34;: { \u0026#34;env\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;S3UserfilesBucketName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;DynamoDBPhotosTableArn\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; } }, \t\u0026#34;Resources\u0026#34;: { \u0026#34;LambdaFunction\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::Lambda::Function\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;Handler\u0026#34;: \u0026#34;index.handler\u0026#34;, \u0026#34;FunctionName\u0026#34;: \u0026#34;workshopphotoprocessor\u0026#34;, \t\u0026#34;Role\u0026#34;: { \u0026#34;Fn::GetAtt\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34;, \u0026#34;Arn\u0026#34; ] }, \u0026#34;Runtime\u0026#34;: \u0026#34;nodejs8.10\u0026#34;, \u0026#34;Timeout\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;Environment\u0026#34;: { \u0026#34;Variables\u0026#34;: { \u0026#34;ENV\u0026#34;: {\u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34;}, \u0026#34;THUMBNAIL_WIDTH\u0026#34;: \u0026#34;80\u0026#34;, \u0026#34;THUMBNAIL_HEIGHT\u0026#34;: \u0026#34;80\u0026#34;, \u0026#34;DYNAMODB_PHOTOS_TABLE_ARN\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;DynamoDBPhotosTableArn\u0026#34; } } } \t} }, \u0026#34;LambdaExecutionRole\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Role\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;RoleName\u0026#34;: \u0026#34;photoalbumsLambdaRole91d2faf3\u0026#34;, \u0026#34;AssumeRolePolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;lambda.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: [ \u0026#34;sts:AssumeRole\u0026#34; ] } ] } } }, \u0026#34;lambdaexecutionpolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;lambda-execution-policy\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Fn::Sub\u0026#34;: [ \u0026#34;arn:aws:logs:${region}:${account}:log-group:/aws/lambda/${lambda}:log-stream:*\u0026#34;, { \u0026#34;region\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; }, \u0026#34;account\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;lambda\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaFunction\u0026#34; } } ] } } ] } } }, \u0026#34;AllPrivsForPhotoAlbums\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;AllPrivsForPhotoAlbums\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:*\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Fn::Sub\u0026#34;: [ \u0026#34;arn:aws:s3:::${S3UserfilesBucketName}/*\u0026#34;, { \u0026#34;S3UserfilesBucketName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;S3UserfilesBucketName\u0026#34; } } ] } } ] } } }, \u0026#34;AllPrivsForDynamo\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;AllPrivsForDynamo\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;dynamodb:*\u0026#34; ], \u0026#34;Resource\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;DynamoDBPhotosTableArn\u0026#34; } } ] } } }, \u0026#34;RekognitionDetectLabels\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;LambdaExecutionRole\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;RekognitionDetectLabels\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaExecutionRole\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;rekognition:detectLabels\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } } }\t\t}, \u0026#34;Outputs\u0026#34;: { \u0026#34;Name\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;LambdaFunction\u0026#34; } }, \u0026#34;Arn\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Fn::GetAtt\u0026#34;: [ \u0026#34;LambdaFunction\u0026#34;, \u0026#34;Arn\u0026#34; ] } }, \u0026#34;Region\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; } } } } \n photo-albums 디렉터리에서 amplify push 실행하여 새 함수를 배포합니다.\n 배포를 마칠 때까지 기다립니다. 이 단계는 1~2분 정도 소요됩니다.\n  변경된 것  사진 처리 함수의 클라우드포메이션 템플릿에 값을 전달해줄 parameters.json 파일을 생성하였습니다. (photo-albums/amplify/backend/function/workshopphotoprocessor/parameters.json)\n 사진 처리 함수의 클라우드포메이션 템플릿에 env, S3UserfilesBucketName, DynamoDBPhotosTableArn 변수를 추가했습니다. (photo-albums/amplify/backend/function/workshopphotoprocessor/workshopphotoprocessor-cloudformation-template.json)\n 사진 처리 함수의 구성에 ENV, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT, DYNAMODB_PHOTOS_TABLE_ARN 환경 변수를 추가했습니다. (/photo-albums/amplify/backend/function/workshopphotoprocessor/src/index.js)\n 함수에서 사진을 저장하는 S3 버킷에 읽고 쓰기를 허가하는 AllPrivsForPhotoAlbums 라는 IAM 정책을 추가했습니다. (photo-albums/amplify/backend/function/workshopphotoprocessor/workshopphotoprocessor-cloudformation-template.json)\n 함수에서 사진 정보를 수록한 DynamoDB에 읽고 쓰기를 허가하는 AllPrivsForDynamo 라는 IAM 정책을 추가하였습니다.\n 함수에서 Amazon Rekognition의 detectLabels API를 사용할 수 있도록 허가하는 RekognitionDetectLabels 라는 IAM 정책을 추가하였습니다. 이 정책은 아직 사용하지 않지만, 관련 파일을 작업하는 동안이라 편의상 여기에 추가하였으니, 다음 장에서 AI로 자동으로 사진을 태깅하는 것에 관하여 다룰 때 여기로 돌아와서 정책을 추가하지 않아도 됩니다.\n  AWS Amplify CLI는 클라우드포메이션 템플릿을 생성하여 프로젝트의 클라우드 리소스를 관리합니다. 클라우드포메이션 템플릿은 프로젝트의 모든 인프라 구성을 JSON 이나 또는 YAML 파일 형식의 코드로 지정하여 매우 유용합니다. 이 워크샵에서는 생성된 클라우드포메이션 템플릿의 일부를 계속 편집할 것입니다.   모든 변경 사항을 안전하게 적용할 수는 없고, 수정한 클라우드포메이션 템플릿을 Amplify CLI가 덮어 쓸 수 있음을 주의하십시요. 다만 이 워크샵에서는 우리가 수정한 모든 내용은 Amplify가 덮어 쓰지 않는데, 이는 편집한 리소스를 다시 구성하거나 제거하는 명령을 실행하지 않았기 때문으로, CLI를 이용하여 이미 Amplify로 생성한 리소스를 재구성한다면 이런 경우가 발생할 수 있다 는 것을 기억하는 것이 좋습니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up/10_what_we_built.html",
	"title": "축하드립니다!",
	"tags": [],
	"description": "",
	"content": " 실제로 상용할 어플리케이션을 만들진 않았지만, 간단하게 공유가능한 앨범 웹 어플리케이션을 만들어보았습니다.\n우리가 완료한 내용들을 다음 리스트에서 확인해보겠습니다. :\n 간단한 리엑트(React) 웹 어플리케이션을 만들었습니다.\n 사용자 인증 추가로 회원가입 및 로그인을 구현하였습니다.\n DynamoDB 테이블에 저장될 사진과 앨범들이 안전하게 관리되도록 AWS AppSync의 GraphQL API를 이용했습니다.\n 앨범 추가 및 상세보기 기능을 추가하였습니다.\n 앨범에 사진들을 업로드하고 썸네일 자동생성 기능을 구현하였습니다.\n 사진이 많은 앨범의 \u0026ldquo;더보기\u0026rdquo;와 같이 Pagenation 기능을 도입하였습니다.\n Amazon Rekognition API를 이용한 사진 레이블을 자동으로 감지하는 기능을 추가하였습니다.\n (각 사용자별로 지정된 앨범권한 범위 내에서) 레이블 검색을 통해 해당 레이블 정보를 가진 사진을 검색할 수 있는 기능을 추가하였습니다.\n S3 버킷으로 프로덕션버전 어플리케이션을 웹 호스팅을 할 수 있도록 배포하였습니다.\n AWS 서비스들을 이용하여 완전한 서버리스이자, 비용 효율적이며 뛰어난 확장성과 고가용성 어플리케이션을 구현하였습니다.\n  몇시간동안 우리가 한 작업이 괜찮은 것 같네요!\n마지막까지 완수해주신 여러분 스스로를 자랑스러워 해주세요!\n다음엔 무엇을 구축해보시겠어요? "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql/20_trying_out_queries.html",
	"title": "Querie 수행하기",
	"tags": [],
	"description": "",
	"content": " AWS Console에서 AppSync로 이동후에 photoalbums-master API를 클릭합니다. 이제 API를 파고들어봅시다.\n Link to AWS AppSync web console in Seoul\n Link to AWS AppSync web console in Northern Virgina\n Link to AWS AppSync web console in Ireland\n  왼쪽 사이드바에 있는 Queries를 클릭합니다.\nAWS AppSync의 대화형 쿼리 실행 영역인 이곳에서 쿼리를 작성하거나 변경하고, 쿼리를 실행하여 결과를 볼 수 있습니다. 이는 Resolver들이 우리가 예상한 대로 잘 작동하는지 테스트하기 위한 좋은 방법입니다.\n AppSync 인증 쿼리를 실행하기 전에 사용자 인증이 필요합니다. (AppSync API는 Application 인증을 구현할때 세팅한 Amazon Congnito 사용자 Pool을 통하여 인증하도록 설정되어 있기 때문)\n  쿼리 에디터 상단에 있는 Login with User Pools 버튼을 클릭하세요.\n ClientId 필드의 값을 확인합니다.\n Cloud9에서 photo-albums/src/aws-exports.js 파일을 오픈합니다. aws_user_pools_web_client_id 속성의 값을 복사 하세요.  ClientId 필드에 복사한 값을 붙여넣습니다.\n 인증 정보를 추가할때 생성한 사용자 credentials 을 입력하세요.\n ampfli auth 추가한 후 어플리케이션을 실행시켜 로그인 할때 생성했던 User 정보를 입력하면 됩니다.  Login 클릭\n  쿼리 수행하기 이제 다음 쿼리와 Mutations를 수행하면 됩니다. 쿼리와 mutations 실행을 위해 주황색 \u0026lsquo;play\u0026rsquo; 버튼을 클릭하세요.\n새로운 앨범 추가하기 : 다음 문장을 복사 붙여넣기 하여 쿼리를 실행합니다.\nmutation { createAlbum(input:{name:\u0026quot;First Album\u0026quot;}) { id name } }  다른 앨범 추가하기 : 다른 앨범 이름으로 createAlbum mutation를 수정하고 재실행 합니다.\nmutation { createAlbum(input:{name:\u0026quot;Second Album\u0026quot;}) { id name } }  앨범 목록 조회하기 : 다음 쿼리를 실행합니다.\nquery { listAlbums { items { id name } } }  보다시피, GraphQL 쿼리와 mutation으로 데이터를 읽고 작성할 수 있습니다. AppSync는 데이터 조회와 데이터 보존(Persisting)을 담당합니다.(이 예시는 DynamoDB에 해당).\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus/20_album_membership.html",
	"title": "다른 유저와 앨범 공유하기",
	"tags": [],
	"description": "",
	"content": " 다수의 유저가 우리의 애플리케이션으로 접속할 수 있다는 장점을 이용하여 다른 유저들이 상황에 따라 우리의 앨범을 보고 업로드 할 수 있는 기능을 넣을 수 있습니다.\n가장 쉬운 방법은 각각의 앨범에 유저들의 이름(usernames)을 포함하여 그들이 이 앨범 보고 새로운 사진을 업로드할 수 있도록 하는 것입니다.\n백엔드 수정하기 Amplify는 GraphQL 스키마 안의 @model 타입에서 여러 개의 권한 선언을 지원합니다. 우리는 두 번째 권한 규칙을 추가함으로서 Album의 members 필드에 있는 유저가 해당 레코드를 볼 수 있게 할 수 있습니다. 다만, 레코드를 수정할 권한은 없습니다.\n /photo-albums/amplify/backend/api/photoalbums/schema.graphql 에 위치한 코드를 아래 코드로 대체해 주세요: # amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [ { allow: owner } { allow: owner, ownerField: \u0026#34;members\u0026#34;, queries: [get, list], mutations: null } ]) {  id: ID! name: String! owner: String members: [String]  photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) @searchable { id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! labels: [String!] } type PhotoS3Info { key: String! width: Int! height: Int! } \n 새로운 GraphQL를 재생성하고 AppSync API를 갱신하기 위해서 amplify push 명령을 실행해 주세요.\n  GraphQL Transform 문서를 통하여 모델에 여러 개의 소유권 규칙을 추가하는 방법에 대해 더 알아볼 수 있습니다.\n 프런트엔드 수정하기 이제 우리의 백엔드는 앨범 레코드 내의 members 필드 속에서 usernames 목록을 찾도록 수정되었습니다. 추가로 우리가 해야 할 일은 UI를 수정하여 앨범의 소유자가 앨범의 구성원으로서(members) 속해야 할 유저들(usernames)을 관리할 수 있도록 하는 것입니다. 또한, 또 다른 AppSync 구독에 추가함으로서 앨범에 새로운 유저가 추가될 때마다 유저 목록이 갱신되도록 할 것입니다.\n아래 갱신된 버전의 코드로 photo-albums/src/App.js 를 대체해 주세요: // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Container, Divider, Form, Grid, Header, Icon, Input, List, Modal, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, Auth, graphqlOperation, Storage } from \u0026#39;aws-amplify\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const SubscribeToUpdatedAlbums = ` subscription OnUpdateAlbum { onUpdateAlbum { id name owner members } } `;  const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name owner members photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } fullsize { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } } class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const user = await Auth.currentAuthenticatedUser(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId, owner: user.username } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { constructor(props) { super(props); this.state = { selectedPhoto: null }; } handlePhotoClick = (photo) =\u0026gt; { this.setState({ selectedPhoto: photo }); } handleLightboxClose = () =\u0026gt; { this.setState({ selectedPhoto: null }); } photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} onClick={this.handlePhotoClick.bind(this, photo.fullsize)} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;Lightbox photo={this.state.selectedPhoto} onClose={this.handleLightboxClose} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); const subscription = API.graphql(graphqlOperation(SubscribeToUpdatedAlbums)).subscribe({ next: (update) =\u0026gt; { const album = update.value.data.onUpdateAlbum; this.setState({ album: Object.assign(this.state.album, album) }) } }); this.setState({ albumUpdatesSubscription: subscription }) } componentWillUnmount() { this.state.albumUpdatesSubscription.unsubscribe(); }  render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class Lightbox extends Component { render() { return ( \u0026lt;Modal open={this.props.photo !== null} onClose={this.props.onClose} \u0026gt; \u0026lt;Modal.Content\u0026gt; \u0026lt;Container textAlign=\u0026#39;center\u0026#39;\u0026gt; { this.props.photo? \u0026lt;S3Image imgKey={this.props.photo.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} theme={{ photoImg: { maxWidth: \u0026#39;100%\u0026#39; } }} onClick={this.props.onClose} /\u0026gt; : null } \u0026lt;/Container\u0026gt; \u0026lt;/Modal.Content\u0026gt; \u0026lt;/Modal\u0026gt; ); } } class AlbumDetails extends Component { async componentDidMount() { this.setState({ currentUser: await Auth.currentAuthenticatedUser() }); }  render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; { this.state.currentUser.username === this.props.album.owner \u0026amp;\u0026amp; \u0026lt;Segment.Group\u0026gt; \u0026lt;Segment\u0026gt; \u0026lt;AlbumMembers members={this.props.album.members} /\u0026gt; \u0026lt;/Segment\u0026gt; \u0026lt;Segment basic\u0026gt; \u0026lt;AddUsernameToAlbum albumId={this.props.album.id} /\u0026gt; \u0026lt;/Segment\u0026gt; \u0026lt;/Segment.Group\u0026gt; }  \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class AddUsernameToAlbum extends Component { constructor(props) { super(props); this.state = { username: \u0026#39;\u0026#39; }; } handleChange = (e, { name, value }) =\u0026gt; this.setState({ [name]: value }) handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.albumId})); let updatedAlbum = data.getAlbum; const updatedMembers = (data.getAlbum.members || []).concat([this.state.username]); updatedAlbum.members = updatedMembers; const {id, name, owner, members} = updatedAlbum; const updatedAlbumInput = {id, name, owner, members}; const UpdateAlbum = `mutation UpdateAlbum($input: UpdateAlbumInput!) { updateAlbum(input: $input) { id members } } `; const result = await API.graphql(graphqlOperation(UpdateAlbum, { input: updatedAlbumInput })); console.log(`Added ${this.state.username}to album id ${result.data.updateAlbum.id}`); this.setState({ username: \u0026#39;\u0026#39; }); } render() { return ( \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Username\u0026#39; icon=\u0026#39;user plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Add\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;username\u0026#39; value={this.state.username} onChange={this.handleChange} /\u0026gt; ) } } const AlbumMembers = (props) =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h4\u0026#39;\u0026gt; \u0026lt;Icon name=\u0026#39;user circle\u0026#39; /\u0026gt; \u0026lt;Header.Content\u0026gt;Members\u0026lt;/Header.Content\u0026gt; \u0026lt;/Header\u0026gt; { props.members ? \u0026lt;List bulleted\u0026gt; {props.members \u0026amp;\u0026amp; props.members.map((member) =\u0026gt; \u0026lt;List.Item key={member}\u0026gt;{member}\u0026lt;/List.Item\u0026gt;)} \u0026lt;/List\u0026gt; : \u0026#39;No members yet (besides you). Invite someone below!\u0026#39; } \u0026lt;/div\u0026gt; );  class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nsrc/App.js 에서 무엇이 수정되었나요  semantic-ui-react에서 Icon 를, aws-amplify에서 Auth 를 불러왔습니다.\n SubscribeToUpdatedAlbums 쿼리를 추가하였습니다.\n GetAlbum 쿼리로 가져오는(fetch) owner 와 member 필드를 추가 하였습니다.\n 새로운 멤버가 추가 되었을 때 앨범을 다시 렌더링 하는 작업을 발생시키기 위하여 AlbumDetailsLoader 컴포넌트 내에서 앨범의 갱신을 구독하였습니다.\n 멤버들을 관리하기 위한 UI를 추가하기 위하여 AlbumDetails 컴포넌트 속의 render() 메소드를 수정하였습니다.\n 유저 추가 기능과 목록화(listing)를 제공하기 위해서 앨범의 소유자에게만 보이는 AddUsernameToAlbum 와 AlbumMembers 컴포넌트 를 생성하였습니다.\n  어플리케이션을 작동시켜 보세요 새로운 multi-user 기능을 사용하기 위해서는 앨범에 초대할 한명 이상의 유저가 필요합니다.\n 어플리케이션에 로그아웃하고 새로운 유저를 생성합니다 (인증 메일을 확인하는 것과 인증 코드를 제출하는 것을 잊지 마세요).\n 새로운 유저에서 로그아웃하고 기존의 유저로 다시 로그인합니다.\n 공유하고 싶은 앨범으로 이동한 뒤 새로운 유저를 앨범에 초대합니다.\n 로그아웃하고 다시 새로운 유저로 로그인하면 해당 앨범이 보일 것입니다! 또한 새로운 유저가 앨범에 대한 소유권이 없기 때문에 앨범 멤버쉽 관리 기능이 보이지 않는 것을 알 수 있습니다.\n  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up/20_cleanup.html",
	"title": "리소스 삭제하기",
	"tags": [],
	"description": "",
	"content": " Amplify로 삭제하기 Amplify는 우리가 이번 워크샵에서 프로비저닝했던 모든 리소스들을 삭제하는 작업을 할 수 있습니다 (프로비저닝된 CloudFormation 중첩스택을 삭제하는 작업을 시도합니다). 그러나 몇가지 리소스들은 수동으로 삭제해줘야 합니다. (삭제 거부)\n photo-albums 디렉토리에서 amplify delete를 실행하고 삭제를 확인하기 위해 Enter 키를 누릅니다.\n Amplify가 리소스들을 삭제하는 동안 기다립니다.\n  삭제 작업이 실패한 일부 리소스를 수동으로 삭제하기 이제 CloudFormation stacks console로 이동해서 \u0026lsquo;DELETE FAILED\u0026rsquo;상태표시를 나타내는 몇개의 스택들을 클릭합니다. 삭제 실패된 원인과 무엇이 실패되었는지를 보실 수 있습니다.\nCloudFormation이 스택들을 삭제하려고 할 때 인증된 사용자의 IAM역할이 있다고 하더라도 연동된 정책들이 남아 있다면 이 때문에 삭제 작업이 실패합니다. 하지만 이 시점에서 연동된 정책들 역시 모두 삭제 되어야하며 다른 스택 삭제 작업도 성공해야 합니다.\n 삭제실패된 스택을 선택합니다.\n Actions을 클릭합니다.\n 스택삭제를 선택합니다.\n Auth 역할을 클릭해제하고, 예, 삭제합니다를 클릭합니다.\n 성공적으로 삭제되었는지 확인합니다. 만약 삭제되지 않았다면, IAM Roles console으로 이동한 후, 해당역할( \u0026lsquo;photoalbums\u0026rsquo;로 시작합니다 )을 검색해서 선택 및 삭제해주세요.\n  Amplify가 생성한 S3 버킷은 자동으로 삭제되지 않습니다. 버킷을 삭제하려면 다음 단계를 따르세요 :\n S3 console로 이동합니다.\n 생성일자 열을 클릭하여 최근생성된 버킷들을 순차적으로 정렬합니다.\n 각 photoalbums* 버킷별로 클릭하고 버킷 삭제 버튼을 클릭하여 삭제 확인을 하기위해 버킷명을 복사/붙여넣기합니다.\n  Cloud9 워크스페이스 삭제하기  Cloud9 Environment로 이동합니다.\n workshop으로 생성된 개발환경을 선택 후 삭제를 누릅니다.\n 확인란에 \u0026lsquo;삭제\u0026rsquo;구문을 입력하고 삭제를 클릭합니다.\n  "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails/20_connecting_the_lambda_to_the_bucket.html",
	"title": "사진 버킷을 처리함수와 연결하기",
	"tags": [],
	"description": "",
	"content": " 새 사진이 S3 버킷에 업로드된 후에 함수 동작시키기 사진 처리 함수를 만들었으니 이제는 함수를 실행하는 트리거를 설정해야합니다. 앨범에 업로드된 모든 사진을 처리해야 하기 때문에, Amplify로 생성한 S3 사용자 파일 버킷의 구성을 수정하여 이러한 변경 작업을 수행합니다.\n photo-albums/amplify/backend/storage/photoalbumsstorage/s3-cloudformation-template.json 파일을 다음 내용으로 변경해주십시요. { \u0026#34;AWSTemplateFormatVersion\u0026#34;: \u0026#34;2010-09-09\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;S3 resource stack creation using Amplify CLI\u0026#34;, \u0026#34;Parameters\u0026#34;: { \u0026#34;bucketName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authPolicyName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthPolicyName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;authRoleName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;unauthRoleName\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3PublicPolicy\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3PrivatePolicy\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3ProtectedPolicy\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3UploadsPolicy\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3ReadPolicy\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3PermissionsAuthenticatedPublic\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3PermissionsAuthenticatedProtected\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3PermissionsAuthenticatedPrivate\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3PermissionsAuthenticatedUploads\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;s3PermissionsGuestPublic\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; },\t\u0026#34;s3PermissionsGuestUploads\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;AuthenticatedAllowList\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \u0026#34;GuestAllowList\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; }, \t\u0026#34;selectedGuestPermissions\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;CommaDelimitedList\u0026#34; }, \u0026#34;selectedAuthenticatedPermissions\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;CommaDelimitedList\u0026#34; }, \u0026#34;env\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;String\u0026#34; } }, \u0026#34;Conditions\u0026#34;: { \u0026#34;ShouldNotCreateEnvResources\u0026#34;: { \u0026#34;Fn::Equals\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34; }, \u0026#34;NONE\u0026#34; ] }, \u0026#34;CreateAuthPublic\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;s3PermissionsAuthenticatedPublic\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] }, \u0026#34;CreateAuthProtected\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;s3PermissionsAuthenticatedProtected\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] }, \u0026#34;CreateAuthPrivate\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;s3PermissionsAuthenticatedPrivate\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] }, \u0026#34;CreateAuthUploads\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;s3PermissionsAuthenticatedUploads\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] }, \u0026#34;CreateGuestPublic\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;s3PermissionsGuestPublic\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] }, \u0026#34;CreateGuestUploads\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;s3PermissionsGuestUploads\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] }, \u0026#34;AuthReadAndList\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;AuthenticatedAllowList\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] }, \u0026#34;GuestReadAndList\u0026#34;: { \u0026#34;Fn::Not\u0026#34; : [{ \u0026#34;Fn::Equals\u0026#34; : [ {\u0026#34;Ref\u0026#34; : \u0026#34;GuestAllowList\u0026#34;}, \u0026#34;DISALLOW\u0026#34; ] }] } }, \u0026#34;Resources\u0026#34;: { \u0026#34;InvokePhotoProcessorLambda\u0026#34;: { \u0026#34;Type\u0026#34; : \u0026#34;AWS::Lambda::Permission\u0026#34;, \u0026#34;Properties\u0026#34; : { \u0026#34;Action\u0026#34; : \u0026#34;lambda:InvokeFunction\u0026#34;, \u0026#34;FunctionName\u0026#34; : \u0026#34;workshopphotoprocessor\u0026#34;, \u0026#34;Principal\u0026#34; : \u0026#34;s3.amazonaws.com\u0026#34;, \u0026#34;SourceAccount\u0026#34; : { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;SourceArn\u0026#34;: { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;bucketName\u0026#34; }, \u0026#34;-\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34; } ] ] } } }, \t\u0026#34;S3Bucket\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;AWS::S3::Bucket\u0026#34;, \u0026#34;DeletionPolicy\u0026#34; : \u0026#34;Retain\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;BucketName\u0026#34;: { \u0026#34;Fn::If\u0026#34;: [ \u0026#34;ShouldNotCreateEnvResources\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;bucketName\u0026#34; }, { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ { \u0026#34;Ref\u0026#34;: \u0026#34;bucketName\u0026#34; }, \u0026#34;-\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;env\u0026#34; } ] ] } ] }, \u0026#34;CorsConfiguration\u0026#34;: { \u0026#34;CorsRules\u0026#34;: [ { \u0026#34;AllowedHeaders\u0026#34;: [ \u0026#34;*\u0026#34; ], \u0026#34;AllowedMethods\u0026#34;: [ \u0026#34;GET\u0026#34;, \u0026#34;HEAD\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;DELETE\u0026#34; ], \u0026#34;AllowedOrigins\u0026#34;: [ \u0026#34;*\u0026#34; ], \u0026#34;ExposedHeaders\u0026#34;: [ \u0026#34;x-amz-server-side-encryption\u0026#34;, \u0026#34;x-amz-request-id\u0026#34;, \u0026#34;x-amz-id-2\u0026#34;, \u0026#34;ETag\u0026#34; ], \u0026#34;Id\u0026#34;: \u0026#34;S3CORSRuleId1\u0026#34;, \u0026#34;MaxAge\u0026#34;: \u0026#34;3000\u0026#34; } ] }, \u0026#34;NotificationConfiguration\u0026#34;: { \u0026#34;LambdaConfigurations\u0026#34;: [ { \u0026#34;Function\u0026#34;: { \u0026#34;Fn::Join\u0026#34;: [\u0026#34;:\u0026#34;, [ \u0026#34;arn:aws:lambda\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; }, { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::AccountId\u0026#34; }, \u0026#34;function\u0026#34;, \u0026#34;workshopphotoprocessor\u0026#34; ] ] }, \u0026#34;Event\u0026#34;: \u0026#34;s3:ObjectCreated:Put\u0026#34;, \u0026#34;Filter\u0026#34;: { \u0026#34;S3Key\u0026#34;: { \u0026#34;Rules\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;prefix\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;uploads/\u0026#34; } ] } } } ] } \t} }, \u0026#34;DenyListS3BucketsAuth\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;DenyListS3Buckets\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Deny\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [\u0026#34;*\u0026#34;] } ] } } }, \u0026#34;DenyListS3BucketsGuest\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: \u0026#34;DenyListS3BucketsGuest\u0026#34;, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Deny\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [\u0026#34;*\u0026#34;] } ] } } },\t\t\u0026#34;S3AuthPublicPolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;CreateAuthPublic\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3PublicPolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: { \u0026#34;Fn::Split\u0026#34; : [ \u0026#34;,\u0026#34; , { \u0026#34;Ref\u0026#34;: \u0026#34;s3PermissionsAuthenticatedPublic\u0026#34; } ] }, \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthProtectedPolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;CreateAuthProtected\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3ProtectedPolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: { \u0026#34;Fn::Split\u0026#34; : [ \u0026#34;,\u0026#34; , { \u0026#34;Ref\u0026#34;: \u0026#34;s3PermissionsAuthenticatedProtected\u0026#34; } ] }, \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthPrivatePolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;CreateAuthPrivate\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3PrivatePolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: { \u0026#34;Fn::Split\u0026#34; : [ \u0026#34;,\u0026#34; , { \u0026#34;Ref\u0026#34;: \u0026#34;s3PermissionsAuthenticatedPrivate\u0026#34; } ] }, \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthUploadPolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;CreateAuthUploads\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3UploadsPolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: { \u0026#34;Fn::Split\u0026#34; : [ \u0026#34;,\u0026#34; , { \u0026#34;Ref\u0026#34;: \u0026#34;s3PermissionsAuthenticatedUploads\u0026#34; } ] }, \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3AuthReadPolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;AuthReadAndList\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3ReadPolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;authRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/\u0026#34;, \u0026#34;private/${cognito-identity.amazonaws.com:sub}/*\u0026#34; ] } } } ] } } }, \u0026#34;S3GuestPublicPolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;CreateGuestPublic\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3PublicPolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: { \u0026#34;Fn::Split\u0026#34; : [ \u0026#34;,\u0026#34; , { \u0026#34;Ref\u0026#34;: \u0026#34;s3PermissionsGuestPublic\u0026#34; } ] }, \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/public/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3GuestUploadPolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;CreateGuestUploads\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3UploadsPolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: { \u0026#34;Fn::Split\u0026#34; : [ \u0026#34;,\u0026#34; , { \u0026#34;Ref\u0026#34;: \u0026#34;s3PermissionsGuestUploads\u0026#34; } ] }, \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/uploads/*\u0026#34; ] ] } ] } ] } } }, \u0026#34;S3GuestReadPolicy\u0026#34;: { \u0026#34;DependsOn\u0026#34;: [ \u0026#34;S3Bucket\u0026#34; ], \u0026#34;Condition\u0026#34;: \u0026#34;GuestReadAndList\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;AWS::IAM::Policy\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;PolicyName\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;s3ReadPolicy\u0026#34; }, \u0026#34;Roles\u0026#34;: [ { \u0026#34;Ref\u0026#34;: \u0026#34;unauthRoleName\u0026#34; } ], \u0026#34;PolicyDocument\u0026#34;: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObject\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;/protected/*\u0026#34; ] ] } ] }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34; ], \u0026#34;Resource\u0026#34;: [ { \u0026#34;Fn::Join\u0026#34;: [ \u0026#34;\u0026#34;, [ \u0026#34;arn:aws:s3:::\u0026#34;, { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; } ] ] } ], \u0026#34;Condition\u0026#34;: { \u0026#34;StringLike\u0026#34;: { \u0026#34;s3:prefix\u0026#34;: [ \u0026#34;public/\u0026#34;, \u0026#34;public/*\u0026#34;, \u0026#34;protected/\u0026#34;, \u0026#34;protected/*\u0026#34; ] } } } ] } } } }, \u0026#34;Outputs\u0026#34;: { \u0026#34;BucketName\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;S3Bucket\u0026#34; }, \u0026#34;Description\u0026#34;: \u0026#34;Bucket name for the S3 bucket\u0026#34; }, \u0026#34;Region\u0026#34;: { \u0026#34;Value\u0026#34;: { \u0026#34;Ref\u0026#34;: \u0026#34;AWS::Region\u0026#34; } } } } \n photo-albums 디렉터리에서 amplify push 실행하여 저장소 구성을 갱신합니다.\n 완료될 때까지 기다립니다. 이 단계는 1~2분 정도 소요됩니다.\n  s3-cloudformation-template.json 에서 변경한 내용  PhotoProcessor 람다 함수를 호출할 수 있도록 S3Bucket 리소스에 권한을 부여하는 InvokePhotoProcessorLambda 리소스를 추가하였습니다.\n 새 사진이 \u0026lsquo;uploads/\u0026rsquo; 접두어로 추가되었을 때에 PhotoProcessor 람다함수를 호출하도록 버킷을 구성하게 S3Bucket 리소스에 NotificationConfiguration 속성을 추가하였습니다.\n 인증된 사용자가 S3 버킷 내용 목록을 보는 것을 방지하기 위해 DenyListS3Buckets 라는 IAM 정책을 추가하였습니다.\n  S3 스토리지의 사용자 파일의 기본 권한은 Amplify CLI에서 \u0026lsquo;public/\u0026rsquo;(과 다른 일부 접두어도)으로 시작하는 버킷이라면 어플리케이션에 로그인한 사용자가 버킷 내용을 나열할 수 있게 설정합니다. 이런 상호작용은 어플리케이션에서 노출하지 않으니, 어플리케이션을 찔러보는 누군가는 어플리케이션에 자격증명(credential)을 가져와서 S3 API를 직접 호출하여 모든 사진이 있는 버킷을 나열하는 시도를 할 수 있습니다.   사용자가 버킷 내용을 모두 열거할 필요는 없으니 인증된 사용자가 S3 버킷 내용을 나열 할 수 있는 기능을 명시적으로 거부하도록 IAM 정책을 역할로 추가했습니다.   이제 아무도 S3 API로 직접 호출하여 사용자가 업로드한 사진을 나열할 수 없습니다. 앨범과 사진의 ID로 UUID를 사용하기 때문에 사진을 찾기 위해 ID 패턴을 열거하는 호기심 많은 사용자들도 걱정할 필요없습니다.\n 다른 사진 업로드 시도 이러한 변경 사항이 완료되면, 사진을 업로드할 수 있고 사진 처리 함수가 자동으로 실행되는 것을 확인할 수 있습니다. 사진을 앨범에 업로드하고 잠시 기다린 다음 페이지를 새로 고침하여 앨범이 새로 업로드된 사진을 표시하는지 확인하십시요. 사진이 표시되면 사진 처리 함수가 업로드에 의해 자동으로 시작되어 썸네일 이미지가 생성되고 AppSync API가 읽은 처리된 사진의 정보들도 DynamoDB 테이블에 모두 추가되었음을 의미합니다.\n새로운 사진을 보기 위해 앨범보기를 새로 고치는 것은 좋은 사용자 경험이 아니지만, 이 워크샵에는 이미 많은 내용이 있고 다음장에도 더 많은 내용이 수록되어 있습니다. 짧게 말씀드려본다면, 다른 AppSync 구독으로 이것을 처리하는 한가지 방법은 사진 처리 람다 함수가 AppSync API에서 수정사항을 발생시키고 AlbumDetailsLoader 컴포넌트에서 해당 수정사항을 구독하는 것입니다. 그런데 AppSync API에 Amazon Cognito 사용자 풀 인증을 사용하고 있기 때문에, 람다 기능을 통해 이러한 수정사항을 일으키는 유일한 방법은 일종의 \u0026lsquo;시스템\u0026rsquo; 사용자를 만들고(일반 사용자 가입 및 확인 프로세스를 통해), 사용자 자격증명을 안전하게 저장하고(AWS Secrets Manager 등으로), 수정사항을 유발하도록 람다 내부에서 AppSync API에 사용자로서 인증하는 방법입니다. 간단히 하기위해 여기서는 계속해서 앨범보기를 새로 고치는 방법으로 진행할 것입니다.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/20_prep_for_searching.html",
	"title": "사진을 검색할 수 있게 만들기",
	"tags": [],
	"description": "",
	"content": " GraphQL 스키마 갱신하기 이제 각 사진의 레이블을 저장할 수 있으니, AppSync API를 통해 이 데이터를 노출할 준비가 되었습니다.\nDynamoDB 쿼리로 검색하는 방법도 가능하지만, Amazon Elasticsearch Service를 사용하여 데이터를 색인하고 검색 쿼리를 다루는 방식이 좀 더 유연하고 효율적입니다. 다행이 Amplify CLI는 매우 쉽게 Amazon Elasticsearch 엔드포인트를 생성하고 어플리케이션 데이터와 연결합니다.\n photo-albums/amplify/backend/api/photoalbums/schema.graphql 을 다음 내용으로 변경합니다. # amplify/backend/api/photo-albums/schema.graphql type Album @model @auth(rules: [{allow: owner}]) { id: ID! name: String! photos: [Photo] @connection(name: \u0026#34;AlbumPhotos\u0026#34;) } type Photo @model @auth(rules: [{allow: owner}]) @searchable {  id: ID! album: Album @connection(name: \u0026#34;AlbumPhotos\u0026#34;) bucket: String! fullsize: PhotoS3Info! thumbnail: PhotoS3Info! labels: [String!] } type PhotoS3Info { key: String! width: Int! height: Int! }\n photo-albums 디렉터리에서 amplify push 실행하여 새로운 리소스를 프로비저닝합니다.\n 갱신이 끝날때까지 기다립니다. 새로운 Amazon Elasticsearch Service 엔드포인트를 생성하는데 몇 분이 소요될 수 있습니다. 이 과정은 보통 완료까지 8분에서 12분정도 소요됩니다.\n  Amplify의 GraphQL 변환에서 Amplify의 @searchable GraphQL 지시문에 대해 더 공부할 수 있습니다.\n 바뀐 것들  Amplify가 Amazon Elasticsearch Service 클러스터에 사진 데이터를 연결하는 @searchable 지시문을 Photo 타입으로 추가했습니다.\n Photo 타입에 labels 속성을 추가하여, 사진 처리 함수에서 추가된 레이블 정보도 검색할 수 있도록 Elasticserarch Service에 사진 기록의 일부로 스트리밍합니다.\n  amplify push 작업이 완료되기까지 기다리는 중에 다음 장을 계속 진행할 수 있습니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/10_prerequisites/20_software.html",
	"title": "설치 &amp; 설정",
	"tags": [],
	"description": "",
	"content": " 코딩을 시작하기 전에, Cloud9 환경에 몇 가지 설치, 업데이트, 설정을 해야합니다.\n로컬 환경에서 실습을 진행하실 분들은 각자 환경에 맞춰서 설정하시기 바랍니다.\n 설치와 업데이트 Cloud9 터미널에서 다음 명령어를 수행하세요. 우리가 사용할 몇 가지 소프트웨어를 설치하고 업데이트 합니다.\n# Update the AWS CLI pip install --user --upgrade awscli # Install and use Node.js v8.11 (to match AWS Lambda) nvm install v8.11.0 nvm alias default v8.11.0 # Install the AWS Amplify CLI npm install -g @aws-amplify/cli 이 명령어들은 완료 되는데 시간이 수 분이 소요됩니다.\n 기본 region 설정하기 가장 좋은 방법은 인프라를 고객과 가까운 지역에 구성하는 것입니다. (Amplify는 서울 리전도 지원합니다.)\n이번 워크샵에서는 기본 AWS region을 다음 지역으로 설정합니다:\n- 한국 - Seoul (ap-northeast-2)\n- 미국 - Northern Virginia (us-east-1)\n- 유럽 - Ireland (eu-west-1)\nAWS config file 생성하기, 실행:\n cat \u0026lt;\u0026lt;END \u0026gt; ~/.aws/config [default] region=ap-northeast-2 END  cat \u0026lt;\u0026lt;END \u0026gt; ~/.aws/config [default] region=us-east-1 END  cat \u0026lt;\u0026lt;END \u0026gt; ~/.aws/config [default] region=eu-west-1 END   AWS Amplify CLI는 모바일과 웹 어플리케이션을 개발을 심플하게 해주는 강력한 기능들을 제공하는 툴체인 입니다. 위의 단계에서는 설치만 진행했기 때문에 설정 단계가 추가적으로 필요합니다. AWS Amplify CLI는 ~/.aws/config을 찾아 작업할 Region 정보를 판별합니다. Cloud9은 유효한 Administrator credentials이 ~/.aws/credentials 파일안에 있는지 확인만 할 뿐 ~/.aws/config을 생성하지 않습니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started.html",
	"title": "시작하기",
	"tags": [],
	"description": "",
	"content": " 시작하기  무엇을 빌드하나   어플리케이션 부트스트래핑   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/20_getting_started/20_bootstrapping_the_app.html",
	"title": "어플리케이션 부트스트래핑",
	"tags": [],
	"description": "",
	"content": " 리액트(React) 어플리케이션 만들기 create-react-app CLI로 새로운 리액트 웹 어플리케이션을 제작하며 시작하겠습니다.\n이는 로컬에서 자동으로 다시 서버를 띄워주는 리액트 샘플 어플리케이션과 브라우저에서 async/await 문법, 화살표 함수 등을 지원하도록 트랜스 컴파일 기능을 제공합니다.\n create-react-app은 https://github.com/facebook/create-react-app에서 좀 더 배울 수 있습니다.\n Cloud9 터미널에서 npx create-react-app photo-albums를 실행하시고 새로 생성된 디렉토리로 이동합니다 cd photo-albums\n 이 명령어를 통해 photo-albums라는 이름을 가진 amplify 어플리케이션의 기본 구조를 생성합니다.\n 시멘틱 UI 리액트 추가하기 UI를 작성하기 전에 인터페이스를 좀 더 근사하게 만들수 있는 리액트의 시멘틱 UI 컴포넌트를 추가합니다.\nphoto-albums 디렉터리에서 npm install --save semantic-ui-react 실행합니다.\n그리고 public/index.html를 수정하고 이 스타일 시트 링크를 추가합니다.\n\u0026lt;head\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.3.3/semantic.min.css\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/head\u0026gt; 어플리케이션 띄워 보기 이제 개발 서버에서 시작해서 수정하면 브라우저에서 즉각 새로고침하여 볼 수 있게 합니다.\nphoto-albums 디렉터리에서 npm start를 실행합니다.\n웹 서버를 시작했으면 Preview 메뉴를 클릭하고 Preview Running Application을 선택합니다.\n원하시면 미리보기를 새 창에 표시할 수 있습니다.\n마지막으로 다른 터미널 윈도우를 엽니다. 첫번째 터미널은 웹 서버 프로세스를 실행 중이므로 남겨둡니다. 마크업 단순화하기 다음으로 깨끗한 상태로 시작하고 싶습니다.\nsrc/App.js를 수정하여 간단히 \u0026lsquo;Hellow World\u0026rsquo; 메시지를 보여주도록 바꿉니다. 파일의 기존 내용을 아래와 같이 변경합니다.\n// src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Header } from \u0026#39;semantic-ui-react\u0026#39;; class App extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h1\u0026#39;\u0026gt;Hello World!\u0026lt;/Header\u0026gt; \u0026lt;/div\u0026gt; ); } } export default App; 이 시점에서 이전에 띄워둔 브라우저는 자동으로 새로고침되고 \u0026lsquo;Hello World\u0026rsquo;라는 텍스트만 있는 훨씬 간단한 페이지가 표시할 것입니다. 아직 못 보았지만 최소한의 마크업으로 시작하는 것이 좋습니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth/20_adding_auth_front.html",
	"title": "프론트엔드 렌더링",
	"tags": [],
	"description": "",
	"content": " 이제 등록과 로그인을 관리하는 백엔드가 구성되었으니 withAuthenticator AWS Amplify의 상위 리액트 컴포넌트를 이용해서 기존 App 컴포넌트를 감싸도록 합니다. 그러면 어플리케이션에서 사용자 등록, 확인, 로그인, 로그 아웃, 비밀번호 재설정을 할 수 있는 간단한 UI를 제공합니다.\nAmplify npm 라이브러리 추가 아직 aws-amplify, aws-amplify-react 모듈을 어플리케이션에 추가하지 않았으니 이제 추가합니다.\n npm install --save aws-amplify aws-amplify-react을 실행합니다.\n src/App.js 내용을 다음으로 교체합니다. // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import { Header } from \u0026#39;semantic-ui-react\u0026#39;; import Amplify from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; import { withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; Amplify.configure(aws_exports);  class App extends Component { render() { return ( \u0026lt;div\u0026gt; \u0026lt;Header as=\u0026#39;h1\u0026#39;\u0026gt;Hello World!\u0026lt;/Header\u0026gt; \u0026lt;/div\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true});\n  이제 웹 어플리케이션을 살펴보면, 사용자 등록과 로그인 양식을 갖게 되었음을 알 수 있습니다!\nApp.js에서 변경한 것들  AWS Amplify JS 라이브러리를 임포트하고 구성했습니다.\n aws-amplify-react에서 withAuthenticator 상위 컴포넌트를 임포트했습니다.\n withAuthenticator로 App 컴포넌트를 감쌌습니다.\n  계정 생성하기 어플리케이션에서 계정을 생성하려면 사용자명, 암호와 확인 코드를 수신할 유효한 이메일 주소가 필요합니다.\n코드를 확인하라는 화면이 보여집니다. 이는 Amazon Cognito가 로그인할 수 있게 하기 전에 사용자의 이메일 주소를 검증하기 때문입니다.\n 이메일을 확인하십시요. 확인 코드를 받았을 것입니다. 확인 코드를 복사하고 어플리케이션에 붙여넣기 하면 가입시 입력한 사용자명과 비밀번호로 로그인할 수 있습니다.\n로그인하면 로그인 양식은 사라지고 사용자명과 \u0026lsquo;Sing Out\u0026rsquo; 버튼이 포함된 헤더바 아래로 랜더링된 App 컴포넌트를 볼 수 있습니다.\n지금은 꽤 간단한 인증 UI이지만 직접 리액트 컴포넌트를 교체하거나 어플리케이션으로 리다이렉션할 수 있는 완전히 호스트된 UI를 사용하는 등의 많은 것을 사용자가 정의할 수 있습니다. 자세한 내용은 AWS Amplify 인증 가이드의 사용자 정의 항목을 보십시요.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos/30_adding_storage.html",
	"title": "Cloud Storage 추가하기",
	"tags": [],
	"description": "",
	"content": " 앨범에 업로드한 모든 사진들을 보관할 저장소가 필요합니다. Amazon Simple Storage Service (S3)는 이를 위한 좋은 서비스이기도 하고 Amplify의 스토리지 모듈을 이용하면 S3에 대한 설정과 작업이 아주 쉽습니다.\n스토리지 구성 및 추가 먼저 Amplify CLI를 사용하여 스토리지를 활성화합니다. Amazon S3에 버킷이 생성되고 적절한 권한으로 설정되어 어플리케이션에 로그인 한 사용자가 읽고 쓸 수 있습니다. 또한 앨범을 공개 하는 경우 인증되지 않은 게스트 사용자가 버킷을 읽을 수 있도록 허용합니다.\nConfiguring and adding storage  사진앨범 디렉토리에서 다음 명령어를 수행합니다. amplify add storage\n 명령창에서 \u0026lsquo;Content\u0026rsquo;를 선택하세요\n 리소스 카테고리명에 값을 입력 합니다.\n 버킷 이름에 기본값 을 수락합니다. 기본값이 아닌 값을 입력하여 생성할 경우, 람다함수 트리거 연결시 문제가 생깁니다.\n 인증된 사용자들은 읽기/쓰기 권한에. 접근할 수 있도록 설정하고, 게스트들 에게는 읽기 권한 만 설정합니다.\n응답 예시는 다음과 같습니다.:\n$ amplify add storage ? Please select from one of the below mentioned services: Content (Images, audio, video, etc.) ? Please provide a friendly name for your resource that will be used to label this category in the project: photoalbumsstorage ? Please provide bucket name: (Enter를 눌러 기본값을 그대로 사용합니다.) ? Who should have access: Auth and guest users ? What kind of access do you want for Authenticated users? (a키를 눌러 모두 선택합니다.) ◉ create/update ◉ read ◉ delete ? What kind of access do you want for Guest users? ◯ create/update ◉ read ◯ delete  Amplify는 방금 추가 한 스토리지 리소스를 프로비저닝하여 클라우드 환경을 수정하게 됩니다.\n 다음 명령어를 실행합니다. amplify push 바뀐 내용을 확인하기 위해 Enter를 누릅니다. 프로비저닝이 완료 될 때까지 기다립니다. 저장 용량을 추가하는 데는 보통 1-2 분 정도 소요됩니다.  Amplify는 게스트 사용자의 읽기권한을 허용하도록 설정했기 때문에 앨범을 공개하는데 S3 bucket 권한 설정을 변경 할 필요가 없습니다. 하지만 이번 워크샵에서는 앨범을 공개적으로 조회할 수 있도록 하지 않겠습니다.\n Amplify 스토리지 모듈에 대해 다음 자료를 참고하세요. here.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/30_adding_auth.html",
	"title": "인증 추가하기",
	"tags": [],
	"description": "",
	"content": " 인증 추가하기  백엔드 구성하기   프론트엔드 렌더링   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/40_graphql.html",
	"title": "GraphQL API 생성하기",
	"tags": [],
	"description": "",
	"content": " GraphQL API 생성하기  AppSync 세팅   Querie 수행하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos/40_upload_photos_consolidated.html",
	"title": "사진 관리하기",
	"tags": [],
	"description": "",
	"content": " 사진을 저장할수 있는 S3 bucket이 생겼으니 사진을 버킷에 사진을 업로드 하도록 도와줄 UI가 필요합니다. 그리고 앨범에 속한 모든 사진들을 로드 하기 위해서 사진들이 앨범에서 어떤 특정 부분에 속하는지 추적 할수 있어야 합니다.\n새로운 S3ImageUpload 컴포넌트를 만들어 봅시다. 이 컴포넌트는 사용자가 사진을 선택할때 이벤트 핸들러를 실행시키는 input 엘리먼트를 가진 HTML이 포함되어 있습니다.\n업로드 이벤트 핸들러를 통해 사진이 어떤 앨범에 들어갈지 설명하는 주석을 가진 메터데이터가 있는 파일을 S3에 업로드 합니다. 다행히 Amplify JS Storage module을 이용하면 S3에 파일업로드 작업을 매우 쉽게 할 수 있습니다. 그리고, 반드시 고유한 이름으로 S3에 파일을 업로드 해야하기 때문에 UUID를 생성해주는 의존 라이브러리가 필요합니다. (사용자 기기에 있는 파일 이름을 그대로 사용한다면 이름 중복 충돌이 발생할수 있습니다).\n photo-albums 디렉토리에서 다음을 수행합니다. npm install --save uuid\n우리 어플리케이션에 의존 라이브러리를 추가하고 S3ImageUpload 컴포넌트를 생성합니다. 그리고 컴포넌트에 생성한 S3ImageUpload 컴포넌트를 포함합니다.\nphoto-albums/src/App.js의 내용을 아래 코드로 교체합니다: // src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import {Divider, Form, Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;;  import { Connect, withAuthenticator, S3Image } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage, Auth } from \u0026#39;aws-amplify\u0026#39;;  import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } } } } }`; class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const user = await Auth.currentAuthenticatedUser(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId, owner: user.username } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;/div\u0026gt; ); } }  class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } }  class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; )  } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \nsrc/App.js 변경사항  의존 라이브러리 추가: v4 as uuid from uuid\n 의존 라이브러리 추가: Divider and Form from semantic-ui-react\n 의존 라이브러리 추가: Storage from aws-amplify\n 의존 라이브러리 추가: S3Image from aws-amplify-react\n 페이징을 제공하기 위한 GetAlbum 쿼리 수정\n 새로운 컴포넌트 생성: S3ImageUpload and PhotosList\n 페이징을 제공하기 위해 AlbumDetailsLoader 수정\n AlbumDetails 에 PhotosList 추가\n  사진 업로드 하기 이 시점에서 봐야 할 것은 별로 없습니다. 업로드 버튼을 클릭하고 파일을 선택한 후, 업로드 버튼으로 다시 바뀌기 전에 \u0026lsquo;Uploading…\u0026rsquo; 으로 바뀌는지 확인해보세요.\nAWS 웹 콘솔에서 S3 버킷을 직접 탐색하여 파일이 업로드되고 있는지 확인할 수도 있습니다. 버킷 이름을 찾는 가장 쉬운 방법은 src / aws-exports.js 파일에서 aws_user_files_s3_bucket 에 설정된 값을 찾는 것입니다. S3 웹 콘솔에서 bucket을 찾아 public/uploads 하위에 업로드 한 파일들을 찾아봅니다.\n 새로 생성한 S3ImageUpload 컴포넌트는 몇가지 호출 기능이 있습니다. 어플리케이션에서 설정한 S3 버킷에 파일을 업로드 하기 위해 AWS Amplify의 Storage.put 메소드를 사용하는데 이 API 호출할때 몇가지 추가 옵션들을 같이 전달합니다.  customPrefix: { public: \u0026lsquo;uploads/\u0026rsquo; } : 자동으로 각 사진들의 미리보기 이미지(thumbnail)를 만들고 싶을 때 전달합니다. S3 버킷에 미리보기 생성 기능을 실행하는 트리거가 추가 되기 때문에, 버킷의 uploads/ 경로에 파일이 추가 될 때마다 트리거가 바로 실행됩니다. 새로운 썸네일들이 추가되면 이 역시 버킷에 추가되기 때문에 각 썸네일이 생성될 때 마다 썸네일 생성 함수가 재 실행되는 재귀 트리거 루프가 발생할수 있습니다. 이를 피하기 위해서 키 프리픽스 uploads/ 를 추가하여 트리거 실행 범위를 제한합니다. Amplify는 공개적으로 액세스 할 수 있어야하는 파일을 특정하기 위해 접두어를 사용한다는 것을 알고 있습니다.이 파일은 Storage.put의 기본 권한 수준입니다.  어플리케이션을 사용하는 사용자라면 누구든지 모든 파일에 대해 접근 할 수 있도록 (API 수준에서) 하는것이 기본정책이라면 문제가 되지 않을까요? 아니요. 우리는 UUID를 사진의 키로 사용하고 있고 사용자들은 앨범의 UUID를 알고 있는 앨범에 대해서면 사진 목록에 접근할 수 있습니다. 만약 당신이 Amplify Storage 모듈의 모든 API를 읽었다면(기본 S3 API에 익숙한 경우) 이렇게 물을지도 모르겠네요. \u0026ldquo;잠시만요, 사용자들은 공개된 경로에 있는 모든 목록을 조회할 수 있으니 모든 사진들을 볼수 있겠는데요?\u0026rdquo; 지금은 당신이맞습니다. 나중에 이를 제한하도록 추가 예방 조치를 취해 처리할 예정입니다. (특정 사용자 이름을 활용하여 버킷 항목 리스트를 조회하지 못하도록 제한함)  metadata: { albumid: this.props.albumId } : S3 썸네일 트리거 함수가 사진에 대한 정보를 데이터 저장소에 추가 하게 합니다. 썸네일 이미지 작성 작업이 완료되고 사진이 업로드된 앨범이 무엇인지 이 옵션을 통해서 알려줍니다. 예를 들면, 사진의 키에 앨범에 ID를 접두사(prefix)나 접미사(suffix)로 추가 할 수 있습니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai/40_searching_for_labels.html",
	"title": "사진을 레이블로 검색하기",
	"tags": [],
	"description": "",
	"content": " 백엔드 작업이 완료되었으니 이제 사진을 레이블로 검색할 수 있게 하겠습니다.\n새 Search 컴포넌트를 생성하고 App 컴포넌트에 루트 경로로 표시되도록 추가합니다. Search 컴포넌트에서 검색된 모든 사진을 표시하기위해 이미 생성한 PhotoList 컴포넌트를 재사용합니다.\nphoto-albums/src/App.js을 다음 내용으로 변경합니다. // photo-albums/src/App.js  import React, { Component } from \u0026#39;react\u0026#39;; import {BrowserRouter as Router, Route, NavLink} from \u0026#39;react-router-dom\u0026#39;; import { Divider, Form, Grid, Header, Input, List, Segment } from \u0026#39;semantic-ui-react\u0026#39;; import {v4 as uuid} from \u0026#39;uuid\u0026#39;; import { Connect, S3Image, withAuthenticator } from \u0026#39;aws-amplify-react\u0026#39;; import Amplify, { API, graphqlOperation, Storage, Auth } from \u0026#39;aws-amplify\u0026#39;; import aws_exports from \u0026#39;./aws-exports\u0026#39;; Amplify.configure(aws_exports); function makeComparator(key, order=\u0026#39;asc\u0026#39;) { return (a, b) =\u0026gt; { if(!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; const aVal = (typeof a[key] === \u0026#39;string\u0026#39;) ? a[key].toUpperCase() : a[key]; const bVal = (typeof b[key] === \u0026#39;string\u0026#39;) ? b[key].toUpperCase() : b[key]; let comparison = 0; if (aVal \u0026gt; bVal) comparison = 1; if (aVal \u0026lt; bVal) comparison = -1; return order === \u0026#39;desc\u0026#39; ? (comparison * -1) : comparison }; } const ListAlbums = `query ListAlbums { listAlbums(limit: 9999) { items { id name } } }`; const SubscribeToNewAlbums = ` subscription OnCreateAlbum { onCreateAlbum { id name } } `; const GetAlbum = `query GetAlbum($id: ID!, $nextTokenForPhotos: String) { getAlbum(id: $id) { id name photos(sortDirection: DESC, nextToken: $nextTokenForPhotos) { nextToken items { thumbnail { width height key } } } } } `; const SearchPhotos = `query SearchPhotos($label: String!) { searchPhotos(filter: { labels: { match: $label }}) { items { id bucket thumbnail { key width height } fullsize { key width height } } } }`; class Search extends React.Component { constructor(props) { super(props); this.state = { photos: [], album: null, label: \u0026#39;\u0026#39;, hasResults: false, searched: false } } updateLabel = (e) =\u0026gt; { this.setState({ label: e.target.value, searched: false }); } getPhotosForLabel = async (e) =\u0026gt; { const result = await API.graphql(graphqlOperation(SearchPhotos, {label: this.state.label})); let photos = []; let label = \u0026#39;\u0026#39;; let hasResults = false; if (result.data.searchPhotos.items.length !== 0) { hasResults = true; photos = result.data.searchPhotos.items; label = this.state.label; } const searchResults = { label, photos } this.setState({ searchResults, hasResults, searched: true }); } noResults() { return !this.state.searched ? \u0026#39;\u0026#39; : \u0026lt;Header as=\u0026#39;h4\u0026#39; color=\u0026#39;grey\u0026#39;\u0026gt;No photos found matching \u0026#39;{this.state.label}\u0026#39;\u0026lt;/Header\u0026gt; } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;Search for photos\u0026#39; icon=\u0026#39;search\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Search\u0026#39;, onClick: this.getPhotosForLabel }} name=\u0026#39;label\u0026#39; value={this.state.label} onChange={this.updateLabel} /\u0026gt; { this.state.hasResults ? \u0026lt;PhotosList photos={this.state.searchResults.photos} /\u0026gt; : this.noResults() } \u0026lt;/Segment\u0026gt; ); } }  class S3ImageUpload extends React.Component { constructor(props) { super(props); this.state = { uploading: false } } uploadFile = async (file) =\u0026gt; { const fileName = uuid(); const user = await Auth.currentAuthenticatedUser(); const result = await Storage.put( fileName, file, { customPrefix: { public: \u0026#39;uploads/\u0026#39; }, metadata: { albumid: this.props.albumId, owner: user.username } } ); console.log(\u0026#39;Uploaded file: \u0026#39;, result); } onChange = async (e) =\u0026gt; { this.setState({uploading: true}); let files = []; for (var i=0; i\u0026lt;e.target.files.length; i++) { files.push(e.target.files.item(i)); } await Promise.all(files.map(f =\u0026gt; this.uploadFile(f))); this.setState({uploading: false}); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Form.Button onClick={() =\u0026gt; document.getElementById(\u0026#39;add-image-file-input\u0026#39;).click()} disabled={this.state.uploading} icon=\u0026#39;file image outline\u0026#39; content={ this.state.uploading ? \u0026#39;Uploading...\u0026#39; : \u0026#39;Add Images\u0026#39; } /\u0026gt; \u0026lt;input id=\u0026#39;add-image-file-input\u0026#39; type=\u0026#34;file\u0026#34; accept=\u0026#39;image/*\u0026#39; multiple onChange={this.onChange} style={{ display: \u0026#39;none\u0026#39; }} /\u0026gt; \u0026lt;/div\u0026gt; ); } } class PhotosList extends React.Component { photoItems() { return this.props.photos.map(photo =\u0026gt; \u0026lt;S3Image key={photo.thumbnail.key} imgKey={photo.thumbnail.key.replace(\u0026#39;public/\u0026#39;, \u0026#39;\u0026#39;)} style={{display: \u0026#39;inline-block\u0026#39;, \u0026#39;paddingRight\u0026#39;: \u0026#39;5px\u0026#39;}} /\u0026gt; ); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;Divider hidden /\u0026gt; {this.photoItems()} \u0026lt;/div\u0026gt; ); } } class NewAlbum extends Component { constructor(props) { super(props); this.state = { albumName: \u0026#39;\u0026#39; }; } handleChange = (event) =\u0026gt; { let change = {}; change[event.target.name] = event.target.value; this.setState(change); } handleSubmit = async (event) =\u0026gt; { event.preventDefault(); const NewAlbum = `mutation NewAlbum($name: String!) { createAlbum(input: {name: $name}) { id name } }`; const result = await API.graphql(graphqlOperation(NewAlbum, { name: this.state.albumName })); console.info(`Created album with id ${result.data.createAlbum.id}`); this.setState({ albumName: \u0026#39;\u0026#39; }) } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;Add a new album\u0026lt;/Header\u0026gt; \u0026lt;Input type=\u0026#39;text\u0026#39; placeholder=\u0026#39;New Album Name\u0026#39; icon=\u0026#39;plus\u0026#39; iconPosition=\u0026#39;left\u0026#39; action={{ content: \u0026#39;Create\u0026#39;, onClick: this.handleSubmit }} name=\u0026#39;albumName\u0026#39; value={this.state.albumName} onChange={this.handleChange} /\u0026gt; \u0026lt;/Segment\u0026gt; ) } } class AlbumsList extends React.Component { albumItems() { return this.props.albums.sort(makeComparator(\u0026#39;name\u0026#39;)).map(album =\u0026gt; \u0026lt;List.Item key={album.id}\u0026gt; \u0026lt;NavLink to={`/albums/${album.id}`}\u0026gt;{album.name}\u0026lt;/NavLink\u0026gt; \u0026lt;/List.Item\u0026gt; ); } render() { return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;My Albums\u0026lt;/Header\u0026gt; \u0026lt;List divided relaxed\u0026gt; {this.albumItems()} \u0026lt;/List\u0026gt; \u0026lt;/Segment\u0026gt; ); } } class AlbumDetailsLoader extends React.Component { constructor(props) { super(props); this.state = { nextTokenForPhotos: null, hasMorePhotos: true, album: null, loading: true } } async loadMorePhotos() { if (!this.state.hasMorePhotos) return; this.setState({ loading: true }); const { data } = await API.graphql(graphqlOperation(GetAlbum, {id: this.props.id, nextTokenForPhotos: this.state.nextTokenForPhotos})); let album; if (this.state.album === null) { album = data.getAlbum; } else { album = this.state.album; album.photos.items = album.photos.items.concat(data.getAlbum.photos.items); } this.setState({ album: album, loading: false, nextTokenForPhotos: data.getAlbum.photos.nextToken, hasMorePhotos: data.getAlbum.photos.nextToken !== null }); } componentDidMount() { this.loadMorePhotos(); } render() { return ( \u0026lt;AlbumDetails loadingPhotos={this.state.loading} album={this.state.album} loadMorePhotos={this.loadMorePhotos.bind(this)} hasMorePhotos={this.state.hasMorePhotos} /\u0026gt; ); } } class AlbumDetails extends Component { render() { if (!this.props.album) return \u0026#39;Loading album...\u0026#39;; return ( \u0026lt;Segment\u0026gt; \u0026lt;Header as=\u0026#39;h3\u0026#39;\u0026gt;{this.props.album.name}\u0026lt;/Header\u0026gt; \u0026lt;S3ImageUpload albumId={this.props.album.id}/\u0026gt; \u0026lt;PhotosList photos={this.props.album.photos.items} /\u0026gt; { this.props.hasMorePhotos \u0026amp;\u0026amp; \u0026lt;Form.Button onClick={this.props.loadMorePhotos} icon=\u0026#39;refresh\u0026#39; disabled={this.props.loadingPhotos} content={this.props.loadingPhotos ? \u0026#39;Loading...\u0026#39; : \u0026#39;Load more photos\u0026#39;} /\u0026gt; } \u0026lt;/Segment\u0026gt; ) } } class AlbumsListLoader extends React.Component { onNewAlbum = (prevQuery, newData) =\u0026gt; { // When we get data about a new album, we need to put in into an object  // with the same shape as the original query results, but with the new data added as well  let updatedQuery = Object.assign({}, prevQuery); updatedQuery.listAlbums.items = prevQuery.listAlbums.items.concat([newData.onCreateAlbum]); return updatedQuery; } render() { return ( \u0026lt;Connect query={graphqlOperation(ListAlbums)} subscription={graphqlOperation(SubscribeToNewAlbums)} onSubscriptionMsg={this.onNewAlbum} \u0026gt; {({ data, loading, errors }) =\u0026gt; { if (loading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } if (errors.length \u0026gt; 0) { return \u0026lt;div\u0026gt;{JSON.stringify(errors)}\u0026lt;/div\u0026gt;; } if (!data.listAlbums) return; return \u0026lt;AlbumsList albums={data.listAlbums.items} /\u0026gt;; }} \u0026lt;/Connect\u0026gt; ); } } class App extends Component { render() { return ( \u0026lt;Router\u0026gt; \u0026lt;Grid padded\u0026gt; \u0026lt;Grid.Column\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={NewAlbum}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={AlbumsListLoader}/\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; exact component={Search}/\u0026gt;  \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ () =\u0026gt; \u0026lt;div\u0026gt;\u0026lt;NavLink to=\u0026#39;/\u0026#39;\u0026gt;Back to Albums list\u0026lt;/NavLink\u0026gt;\u0026lt;/div\u0026gt; } /\u0026gt; \u0026lt;Route path=\u0026#34;/albums/:albumId\u0026#34; render={ props =\u0026gt; \u0026lt;AlbumDetailsLoader id={props.match.params.albumId}/\u0026gt; } /\u0026gt; \u0026lt;/Grid.Column\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Router\u0026gt; ); } } export default withAuthenticator(App, {includeGreetings: true}); \n바뀐 것들  레이블로 사진을 검색하기 위해 SearchPhotos 쿼리를 추가했습니다.\n SearchPhotos 쿼리를 사용하여 레이블에 일치하는 사진 목록을 얻어오고, 기존 PhotosList 컴포넌트를 사용하여 사진을 표시하는 Search 컴포넌트를 추가했습니다.\n 루트 \u0026lsquo;/\u0026rsquo; 경로의 일부로 표시할 Search 컴포넌트를 추가했습니다.\n  사진 검색 기능 시험하기 이제 웹 어플리케이션의 루트 경로 \u0026lsquo;/\u0026lsquo;로 돌아가면 검색할 수 있습니다.\nAmplify로 Amazon Elasticsearch Service를 연동하도록 구성했지만, 생성시에 DynamoDB의 기존 데이터를 전달하지 않기 때문에 오직 새 데이터만을 색인을 생성합니다. 검색 결과를 보려면 먼저 몇 장의 사진을 앨범에 업로드해야 합니다.\n한번 해 봅시다!\n사진을 검색하기 전에 이전 페이지의 amplify push가 완료되었는지 확인하십시요.   사진 검색 기능을 테스트하려면 DynamoDB에 Photos 테이블에 검색어로 사용할 유효한 레이블이 있는지 찾아 보아야 합니다. Rekognition에서 감지된 것과 정확히 일치하는 레이블을 입력해야 합니다.\n "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/50_working_with_albums.html",
	"title": "앨범 작업",
	"tags": [],
	"description": "",
	"content": " 앨범 작업  앨범 관리   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/60_managing_photos.html",
	"title": "사진 관리하기",
	"tags": [],
	"description": "",
	"content": " 사진 관리하기  Cloud Storage 추가하기   사진 관리하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/70_generating_thumbnails.html",
	"title": "미리보기 만들기",
	"tags": [],
	"description": "",
	"content": " 미리보기 만들기  사진을 처리하는 람다 함수 만들기   사진 버킷을 처리함수와 연결하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/110_ai.html",
	"title": "AI 추가하기",
	"tags": [],
	"description": "",
	"content": " AI 추가하기  Amazon Rekognition 연동하기   사진을 검색할 수 있게 만들기   사진을 레이블로 검색하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/120_deploying/10_deploying.html",
	"title": "S3에 어플리케이션 배포하기",
	"tags": [],
	"description": "",
	"content": "우리가 어플리케이션을 구축 및 배포하기 전에, 우리는 Cloud9 인스턴스의 메모리를 올려봅시다. 만약 여러분께서 Cloud9 인스턴스 타입을 micro를 사용한다면 개발 웹서버 구동을 지속하고 프로덕션을 구축할 수 있는 충분한 메모리가 없기때문에 지금이 좋은 기회입니다.\n 개발 웹서버를 구동하고 있는 터미널 탭으로 이동합니다. (npm start 를 실행했던 터미널입니다)\n 개발 웹서버를 중단하고 프로세스를 죽일 수 있도록 Control-C 단축키를 누릅니다.\n  AWS Amplify CLI로 어플리케이션을 공개적으로 접근가능한 S3 버킷에 쉽게 배포할 수 있습니다.\n amplify hosting add를 실행하고 배포 모드(이번 워크샵에서는 \u0026lsquo;Development\u0026rsquo;를 선택합니다)를 선택하여 질문들에 응답합니다.(index와 오류 문서를 위해 index.html를 기본값으로 설정)\n$ amplify hosting add ? Select the environment setup: DEV (S3 only with HTTP) ? hosting bucket name (자동으로 생성되므로 Enter키를 치면 됩니다.) photoalbums-19700101010203--hostingbucket ? index doc for the website index.html ? error doc for the website index.html amplify push를 실행합니다.\n 정적 컨텐츠가 생성되는 어플리케이션을 제공할 새로운 S3 버킷이 생성될 때까지 기다립니다. 이 작업은 보통 1분정도가 소요됩니다.\n amplify publish를 실행합니다.\n Amplify가 프로덕션 버전의 어플리케이션을 구축하고 호스팅 버킷으로 배포하는동안 기다립니다. 이 작업은 보통 1-2분정도가 소요됩니다.\n  구축 및 배포가 완료되고나서, 여러분은 배포된 어플리케이션의 URL을 보실 수 있습니다. 여러분이 변경사항을 반영하여 어플리케이션을 다시 새롭게 호스팅하려면 amplify publish명령어만 재실행하면 됩니다.\n"
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/120_deploying.html",
	"title": "어플리케이션 배포하기",
	"tags": [],
	"description": "",
	"content": " 어플리케이션 배포하기  S3에 어플리케이션 배포하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/130_wrapping_up.html",
	"title": "마무리하기",
	"tags": [],
	"description": "",
	"content": " 마무리하기  축하드립니다!   리소스 삭제하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/140_bonus.html",
	"title": "보너스 컨텐츠",
	"tags": [],
	"description": "",
	"content": " Bonus Content  LIGHTBOX 만들어 전체 크기의 사진들 보기   다른 유저와 앨범 공유하기   "
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://awskrug.github.io/amplify-photo-gallery-workshop/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]